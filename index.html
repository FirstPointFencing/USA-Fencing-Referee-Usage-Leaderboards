<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USA Fencing Referee Leaderboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: #1a472a;
            color: white;
            padding: 30px 0;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            background-color: white;
            border: none;
            font-size: 1rem;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .tab:hover {
            background-color: #f8f8f8;
        }
        
        .tab.active {
            background-color: #1a472a;
            color: white;
            border-bottom-color: #2d7a3d;
        }
        
        .sub-tabs {
            display: none;
            flex-wrap: wrap;
            background-color: #f8f8f8;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .sub-tabs.active {
            display: flex;
        }
        
        .sub-tab {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .sub-tab:hover {
            background-color: #f0f0f0;
        }
        
        .sub-tab.active {
            background-color: #2d7a3d;
            color: white;
            border-color: #2d7a3d;
        }
        
        .content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .leaderboard-table th {
            background-color: #1a472a;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }
        
        .leaderboard-table th:hover {
            background-color: #2d7a3d;
        }
        
        .leaderboard-table th.sort-asc::after {
            content: " ▲";
            font-size: 0.8em;
        }
        
        .leaderboard-table th.sort-desc::after {
            content: " ▼";
            font-size: 0.8em;
        }
        
        .leaderboard-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #eee;
        }
        
        .leaderboard-table tr:hover {
            background-color: #f9f9f9;
        }
        
        .rank {
            font-weight: bold;
            color: #1a472a;
        }
        
        .percentage {
            font-weight: 500;
        }
        
        .search-box {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            position: relative;
        }
        
        .search-box input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .search-box button {
            padding: 10px 20px;
            background-color: #1a472a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .search-box button:hover {
            background-color: #2d7a3d;
        }
        
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .autocomplete-suggestions.active {
            display: block;
        }
        
        .autocomplete-suggestion {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background-color: #f0f0f0;
        }
        
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-card h3 {
            color: #1a472a;
            font-size: 2rem;
            margin-bottom: 5px;
        }
        
        .stat-card p {
            color: #666;
            font-size: 0.9rem;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #666;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            font-size: 1.1rem;
            color: #d32f2f;
        }
        
        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                border-bottom: 1px solid #eee;
            }
            
            .leaderboard-table {
                font-size: 0.9rem;
            }
            
            .leaderboard-table th,
            .leaderboard-table td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>USA Fencing Referee Leaderboard</h1>
        <p>National Level Referee Usage Statistics</p>
    </header>
    
    <div class="container">
        <div class="tabs" id="mainTabs">
            <button class="tab active" onclick="showTab('allTime')">All Time</button>
            <button class="tab" onclick="showTab('finals')">Finals</button>
            <button class="tab" onclick="showTab('nacStats')">NAC Bout Stats</button>
            <button class="tab" onclick="showTab('2024-2025')">2024-2025</button>
            <button class="tab" onclick="showTab('2023-2024')">2023-2024</button>
            <button class="tab" onclick="showTab('2022-2023')">2022-2023</button>
            <button class="tab" onclick="showTab('2021-2022')">2021-2022</button>
            <button class="tab" onclick="showTab('2020-2021')">2020-2021</button>
            <button class="tab" onclick="showTab('2019-2020')">2019-2020</button>
            <button class="tab" onclick="showTab('2018-2019')">2018-2019</button>
            <button class="tab" onclick="showTab('2017-2018')">2017-2018</button>
            <button class="tab" onclick="showTab('2016-2017')">2016-2017</button>
            <button class="tab" onclick="showTab('2015-2016')">2015-2016</button>
            <button class="tab" onclick="showTab('2014-2015')">2014-2015</button>
        </div>
        
        <div id="subTabs" class="sub-tabs active">
            <button class="sub-tab active" onclick="showWeapon('all')">All Weapons</button>
            <button class="sub-tab" onclick="showWeapon('All Saber')">All Saber</button>
            <button class="sub-tab" onclick="showWeapon('All Foil')">All Foil</button>
            <button class="sub-tab" onclick="showWeapon('All Epee')">All Epee</button>
            <button class="sub-tab" onclick="showWeapon('Men\'s Saber')">Men's Saber</button>
            <button class="sub-tab" onclick="showWeapon('Women\'s Saber')">Women's Saber</button>
            <button class="sub-tab" onclick="showWeapon('Men\'s Epee')">Men's Epee</button>
            <button class="sub-tab" onclick="showWeapon('Women\'s Epee')">Women's Epee</button>
            <button class="sub-tab" onclick="showWeapon('Men\'s Foil')">Men's Foil</button>
            <button class="sub-tab" onclick="showWeapon('Women\'s Foil')">Women's Foil</button>
        </div>
        
        <div id="nacSubTabs" class="sub-tabs" style="display: none;">
            <!-- NAC tabs will be dynamically generated here -->
        </div>
        
        <div class="content">
            <p style="font-style: italic; margin-bottom: 15px; color: #666;">
                * Does not include repechage bouts from 2014-2016 seasons
            </p>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search for referee by name..." autocomplete="off">
                <button onclick="searchReferee()">Search</button>
                <button onclick="clearSearch()">Clear</button>
                <div id="autocompleteSuggestions" class="autocomplete-suggestions"></div>
            </div>
            
            <div id="statsContainer" class="stats-summary"></div>
            
            <div id="leaderboardContainer">
                <div class="loading">Loading referee data...</div>
            </div>
        </div>
        
        <footer style="margin-top: 40px; padding: 20px; text-align: center; color: #666; font-size: 0.9rem; border-top: 1px solid #eee;">
            <p><strong>Project Credit:</strong> K. Hone - data streamlining and design | M. Tucker Ph.D - data advisor | C. Cheney - creator, project design</p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        let refereeData = [];
        let finalsData = []; // Store detailed finals data
        let currentTab = 'allTime';
        let currentWeapon = 'all';
        let searchTerm = '';
        let sortColumn = null;
        let sortDirection = 'desc';
        let selectedSuggestionIndex = -1;
        let currentNAC = null;
        let currentNACSeason = null;
        
        // Function to load data from GitHub repository
        async function loadDataFromGitHub() {
            // Using the raw GitHub content URL for your repository - files in root directory
            const baseURL = 'https://raw.githubusercontent.com/FirstPointFencing/USA-Fencing-Referee-Usage-Leaderboards/main/';
            
            const files = [
                { filename: 'Referee_Usage_20142015.csv', season: '2014-2015' },
                { filename: 'Referee_Usage_20152016.csv', season: '2015-2016' },
                { filename: 'Referee_Usage_20162017.csv', season: '2016-2017' },
                { filename: 'Referee_Usage_20172018.csv', season: '2017-2018' },
                { filename: 'Referee_Usage_20182019.csv', season: '2018-2019' },
                { filename: 'Referee_Usage_20192020.csv', season: '2019-2020' },
                { filename: 'Referee_Usage_20202021.csv', season: '2020-2021' },
                { filename: 'Referee_Usage_20212022.csv', season: '2021-2022' },
                { filename: 'Referee_Usage_20222023_Part1.csv', season: '2022-2023' },
                { filename: 'Referee_Usage_20222023_Part2.csv', season: '2022-2023' },
                { filename: 'Referee_Usage_20232024_Part1.csv', season: '2023-2024' },
                { filename: 'Referee_Usage_20232024_Part2.csv', season: '2023-2024' },
                { filename: 'Referee_Usage_20242025.csv', season: '2024-2025' }
            ];
            
            let allData = [];
            let loadedCount = 0;
            
            for (const file of files) {
                try {
                    console.log(`Loading ${file.filename}...`);
                    const response = await fetch(baseURL + file.filename);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    
                    const parsed = Papa.parse(text, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        delimitersToGuess: [',', '\t', '|', ';']
                    });
                    
                    const processedData = processCSVData(parsed.data, file.season);
                    allData = allData.concat(processedData);
                    loadedCount++;
                    
                    console.log(`Loaded ${file.filename}: ${processedData.length} records`);
                    
                    // Update loading progress
                    document.getElementById('leaderboardContainer').innerHTML = 
                        `<div class="loading">Loading referee data... (${loadedCount}/${files.length} files)</div>`;
                    
                } catch (error) {
                    console.error(`Error loading ${file.filename}:`, error);
                }
            }
            
            return allData;
        }
        
        function getWeapon(eventCode) {
            if (!eventCode) return 'Unknown';
            const weaponCode = eventCode.slice(-2).toUpperCase();
            const weaponMap = {
                'MS': 'Men\'s Saber',
                'WS': 'Women\'s Saber',
                'ME': 'Men\'s Epee',
                'WE': 'Women\'s Epee',
                'MF': 'Men\'s Foil',
                'WF': 'Women\'s Foil'
            };
            return weaponMap[weaponCode] || 'Unknown';
        }
        
        function parseRefAssignments(cellValue) {
            if (!cellValue || typeof cellValue !== 'string') return { ref: 0, video: 0 };
            const refMatch = cellValue.match(/Ref:\s*(\d+)/);
            const videoMatch = cellValue.match(/Video:\s*(\d+)/);
            return {
                ref: refMatch ? parseInt(refMatch[1]) : 0,
                video: videoMatch ? parseInt(videoMatch[1]) : 0
            };
        }
        
        function processCSVData(data, season) {
            const processedData = [];
            
            for (const row of data) {
                const lastName = row['Last Name'] || row[''];
                const firstName = row['First Name'];
                
                if (!lastName || !firstName) continue;
                
                const refereeName = `${lastName}, ${firstName}`;
                const weapon = getWeapon(row['Event']);
                
                let totalRef = 0;
                let totalVideo = 0;
                let pools = 0;
                let finals = 0;
                
                // Process pools
                const poolAssignments = parseRefAssignments(row['Pools']);
                pools = poolAssignments.ref + poolAssignments.video;
                totalRef += poolAssignments.ref;
                totalVideo += poolAssignments.video;
                
                // Process each round
                const rounds = ['Table of 512', 'Table of 256', 'Table of 128', 'Table of 64', 
                               'Table of 32', 'Table of 16', 'Table of 8', 'Semi-Finals', 
                               'Bronze Medal Matches', 'Finals'];
                
                for (const round of rounds) {
                    const assignments = parseRefAssignments(row[round]);
                    totalRef += assignments.ref;
                    totalVideo += assignments.video;
                    
                    if (['Finals', 'Bronze Medal Matches', 'Semi-Finals'].includes(round)) {
                        finals += assignments.ref + assignments.video;
                    }
                }
                
                if (totalRef > 0 || totalVideo > 0) {
                    processedData.push({
                        referee: refereeName,
                        season: season,
                        weapon: weapon,
                        event: row['Event'],
                        date: row['Date'],
                        totalMatches: totalRef + totalVideo,
                        headRefMatches: totalRef,
                        videoRefMatches: totalVideo,
                        pools: pools,
                        finals: finals
                    });
                    
                    // Process finals data separately for the Finals tab
                    const finalsRounds = ['Finals', 'Bronze Medal Matches', 'Semi-Finals'];
                    for (const round of finalsRounds) {
                        const assignments = parseRefAssignments(row[round]);
                        if (assignments.ref > 0) {
                            processedData.push({
                                referee: refereeName,
                                season: season,
                                weapon: weapon,
                                event: row['Event'],
                                date: row['Date'],
                                round: round,
                                role: 'Head Referee',
                                count: assignments.ref,
                                isFinalsDetail: true
                            });
                        }
                        if (assignments.video > 0) {
                            processedData.push({
                                referee: refereeName,
                                season: season,
                                weapon: weapon,
                                event: row['Event'],
                                date: row['Date'],
                                round: round,
                                role: 'Video Referee',
                                count: assignments.video,
                                isFinalsDetail: true
                            });
                        }
                    }
                }
            }
            
            return processedData;
        }
        
        function aggregateRefereeData(data) {
            const aggregated = {};
            
            for (const record of data) {
                const key = `${record.referee}|${record.season}|${record.weapon}`;
                
                if (!aggregated[key]) {
                    aggregated[key] = {
                        referee: record.referee,
                        season: record.season,
                        weapon: record.weapon,
                        totalMatches: 0,
                        headRefMatches: 0,
                        videoRefMatches: 0,
                        pools: 0,
                        finals: 0
                    };
                }
                
                aggregated[key].totalMatches += record.totalMatches;
                aggregated[key].headRefMatches += record.headRefMatches;
                aggregated[key].videoRefMatches += record.videoRefMatches;
                aggregated[key].pools += record.pools;
                aggregated[key].finals += record.finals;
            }
            
            // Also aggregate the finals details
            const finalsDetails = data.filter(d => d.isFinalsDetail);
            
            return Object.values(aggregated).concat(finalsDetails);
        }
        
        function showTab(tabName) {
            currentTab = tabName;
            
            // Update tab UI
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent === tabName || 
                    (tabName === 'allTime' && tab.textContent === 'All Time') ||
                    (tabName === 'finals' && tab.textContent === 'Finals') ||
                    (tabName === 'nacStats' && tab.textContent === 'NAC Bout Stats')) {
                    tab.classList.add('active');
                }
            });
            
            // Show/hide appropriate sub-tabs
            if (tabName === 'finals') {
                document.getElementById('subTabs').style.display = 'none';
                document.getElementById('nacSubTabs').style.display = 'none';
            } else if (tabName === 'nacStats') {
                document.getElementById('subTabs').style.display = 'none';
                document.getElementById('nacSubTabs').style.display = 'flex';
                generateNACTabs();
            } else {
                document.getElementById('subTabs').style.display = 'flex';
                document.getElementById('nacSubTabs').style.display = 'none';
            }
            
            updateDisplay();
        }
        
        function showWeapon(weapon) {
            currentWeapon = weapon;
            
            // Update sub-tab UI
            const subTabs = document.querySelectorAll('.sub-tab');
            subTabs.forEach(tab => {
                tab.classList.remove('active');
                if ((weapon === 'all' && tab.textContent === 'All Weapons') || 
                    (weapon === 'All Saber' && tab.textContent === 'All Saber') ||
                    (weapon === 'All Foil' && tab.textContent === 'All Foil') ||
                    (weapon === 'All Epee' && tab.textContent === 'All Epee') ||
                    tab.textContent === weapon) {
                    tab.classList.add('active');
                }
            });
            
            updateDisplay();
        }
        
        function searchReferee() {
            searchTerm = document.getElementById('searchInput').value.toLowerCase();
            updateDisplay();
        }
        
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchTerm = '';
            updateDisplay();
        }
        
        function updateDisplay() {
            // Handle Finals tab separately
            if (currentTab === 'finals') {
                displayFinalsLeaderboard();
                return;
            }
            
            // Handle NAC Stats tab
            if (currentTab === 'nacStats') {
                displayNACStats();
                return;
            }
            
            // Filter data based on current selections
            let filteredData = refereeData;
            
            // Filter by season
            if (currentTab !== 'allTime') {
                filteredData = filteredData.filter(d => d.season === currentTab);
            }
            
            // Filter by weapon
            if (currentWeapon !== 'all') {
                if (currentWeapon === 'All Saber') {
                    filteredData = filteredData.filter(d => d.weapon.includes('Saber'));
                } else if (currentWeapon === 'All Foil') {
                    filteredData = filteredData.filter(d => d.weapon.includes('Foil'));
                } else if (currentWeapon === 'All Epee') {
                    filteredData = filteredData.filter(d => d.weapon.includes('Epee'));
                } else {
                    filteredData = filteredData.filter(d => d.weapon === currentWeapon);
                }
            }
            
            // Filter by search term
            if (searchTerm) {
                filteredData = filteredData.filter(d => 
                    d.referee.toLowerCase().includes(searchTerm)
                );
            }
            
            // Aggregate by referee
            const refereeAggregated = {};
            
            for (const record of filteredData) {
                const referee = record.referee;
                
                if (!refereeAggregated[referee]) {
                    refereeAggregated[referee] = {
                        referee: referee,
                        totalMatches: 0,
                        headRefMatches: 0,
                        videoRefMatches: 0,
                        pools: 0,
                        finals: 0,
                        weapons: new Set(),
                        seasons: new Set()
                    };
                }
                
                refereeAggregated[referee].totalMatches += record.totalMatches;
                refereeAggregated[referee].headRefMatches += record.headRefMatches;
                refereeAggregated[referee].videoRefMatches += record.videoRefMatches;
                refereeAggregated[referee].pools += record.pools;
                refereeAggregated[referee].finals += record.finals;
                refereeAggregated[referee].weapons.add(record.weapon);
                refereeAggregated[referee].seasons.add(record.season);
            }
            
            // Convert to array and sort
            let leaderboardData = Object.values(refereeAggregated);
            
            // Apply sorting
            if (sortColumn !== null) {
                leaderboardData.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch(sortColumn) {
                        case 'referee':
                            aVal = a.referee;
                            bVal = b.referee;
                            break;
                        case 'totalMatches':
                            aVal = a.totalMatches;
                            bVal = b.totalMatches;
                            break;
                        case 'finals':
                            aVal = a.finals;
                            bVal = b.finals;
                            break;
                        case 'pools':
                            aVal = a.pools;
                            bVal = b.pools;
                            break;
                        case 'headRefMatches':
                            aVal = a.headRefMatches;
                            bVal = b.headRefMatches;
                            break;
                        case 'videoRefMatches':
                            aVal = a.videoRefMatches;
                            bVal = b.videoRefMatches;
                            break;
                        case 'headRefPercentage':
                            aVal = a.totalMatches > 0 ? (a.headRefMatches / a.totalMatches) : 0;
                            bVal = b.totalMatches > 0 ? (b.headRefMatches / b.totalMatches) : 0;
                            break;
                        case 'seasons':
                            aVal = a.seasons.size;
                            bVal = b.seasons.size;
                            break;
                        default:
                            aVal = a.totalMatches;
                            bVal = b.totalMatches;
                    }
                    
                    if (typeof aVal === 'string') {
                        return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else {
                        return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                    }
                });
            } else {
                // Default sort by total matches
                leaderboardData.sort((a, b) => b.totalMatches - a.totalMatches);
            }
            
            // Limit to top N based on view
            const limit = currentTab === 'allTime' ? 50 : 25;
            leaderboardData = leaderboardData.slice(0, limit);
            
            // Display statistics
            displayStats(leaderboardData, filteredData);
            
            // Display leaderboard
            displayLeaderboard(leaderboardData);
        }
        
        function displayStats(leaderboardData, rawData) {
            const statsContainer = document.getElementById('statsContainer');
            
            const totalReferees = leaderboardData.length;
            const totalMatches = leaderboardData.reduce((sum, ref) => sum + ref.totalMatches, 0);
            const totalFinals = leaderboardData.reduce((sum, ref) => sum + ref.finals, 0);
            const totalPools = leaderboardData.reduce((sum, ref) => sum + ref.pools, 0);
            
            // Determine the label based on current view
            const refereesLabel = currentTab === 'allTime' ? 'Top 50 Most Active' : 'Top 25 Most Active';
            
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h3>${totalReferees}</h3>
                    <p>${refereesLabel}</p>
                </div>
                <div class="stat-card">
                    <h3>${totalMatches.toLocaleString()}</h3>
                    <p>Total Matches</p>
                </div>
                <div class="stat-card">
                    <h3>${totalFinals.toLocaleString()}</h3>
                    <p>Finals Officiated</p>
                </div>
                <div class="stat-card">
                    <h3>${totalPools.toLocaleString()}</h3>
                    <p>Pools Officiated</p>
                </div>
            `;
        }
        
        function displayLeaderboard(data) {
            const container = document.getElementById('leaderboardContainer');
            
            if (data.length === 0) {
                container.innerHTML = '<p>No data found for the selected criteria.</p>';
                return;
            }
            
            let tableHTML = `
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th onclick="sortTable('rank')">Rank</th>
                            <th onclick="sortTable('referee')">Referee Name</th>
                            <th onclick="sortTable('totalMatches')">Total Matches</th>
                            <th onclick="sortTable('finals')">Finals</th>
                            <th onclick="sortTable('pools')">Pools</th>
                            <th onclick="sortTable('headRefMatches')">Head Ref</th>
                            <th onclick="sortTable('videoRefMatches')">Video Ref</th>
                            <th onclick="sortTable('headRefPercentage')">Head Ref %</th>
                            ${currentTab === 'allTime' ? '<th onclick="sortTable(\'seasons\')">Seasons Active</th>' : ''}
                            ${currentWeapon === 'all' ? '<th>Weapons</th>' : ''}
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            data.forEach((referee, index) => {
                const headRefPercentage = referee.totalMatches > 0 
                    ? ((referee.headRefMatches / referee.totalMatches) * 100).toFixed(1)
                    : '0.0';
                
                // Simplify weapons display
                let weaponsDisplay = '';
                if (currentWeapon === 'all') {
                    const weapons = Array.from(referee.weapons);
                    const hasEpee = weapons.some(w => w.includes('Epee'));
                    const hasFoil = weapons.some(w => w.includes('Foil'));
                    const hasSaber = weapons.some(w => w.includes('Saber'));
                    
                    const simplifiedWeapons = [];
                    if (hasSaber) simplifiedWeapons.push('Saber');
                    if (hasEpee) simplifiedWeapons.push('Epee');
                    if (hasFoil) simplifiedWeapons.push('Foil');
                    
                    weaponsDisplay = simplifiedWeapons.join(', ');
                }
                
                tableHTML += `
                    <tr>
                        <td class="rank">${index + 1}</td>
                        <td>${referee.referee}</td>
                        <td>${referee.totalMatches}</td>
                        <td>${referee.finals}</td>
                        <td>${referee.pools}</td>
                        <td>${referee.headRefMatches}</td>
                        <td>${referee.videoRefMatches}</td>
                        <td class="percentage">${headRefPercentage}%</td>
                        ${currentTab === 'allTime' ? `<td>${referee.seasons.size}</td>` : ''}
                        ${currentWeapon === 'all' ? `<td>${weaponsDisplay}</td>` : ''}
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = tableHTML;
        }
        
        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            updateDisplay();
        }
        
        function sortFinalsTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            displayFinalsLeaderboard();
        }
        
        function setupAutocomplete() {
            const searchInput = document.getElementById('searchInput');
            const suggestionsDiv = document.getElementById('autocompleteSuggestions');
            
            searchInput.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                if (value.length < 2) {
                    suggestionsDiv.classList.remove('active');
                    return;
                }
                
                // Get unique referee names
                const allReferees = [...new Set(refereeData.map(r => r.referee))];
                const matches = allReferees.filter(name => 
                    name.toLowerCase().includes(value)
                ).slice(0, 10); // Limit to 10 suggestions
                
                if (matches.length > 0) {
                    suggestionsDiv.innerHTML = matches.map((name, index) => 
                        `<div class="autocomplete-suggestion" data-index="${index}" onclick="selectSuggestion('${name}')">${name}</div>`
                    ).join('');
                    suggestionsDiv.classList.add('active');
                    selectedSuggestionIndex = -1;
                } else {
                    suggestionsDiv.classList.remove('active');
                }
            });
            
            // Handle keyboard navigation
            searchInput.addEventListener('keydown', function(e) {
                const suggestions = document.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                        selectSuggestion(suggestions[selectedSuggestionIndex].textContent);
                    } else {
                        searchReferee();
                    }
                } else if (e.key === 'Escape') {
                    suggestionsDiv.classList.remove('active');
                }
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                    suggestionsDiv.classList.remove('active');
                }
            });
        }
        
        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((s, index) => {
                if (index === selectedSuggestionIndex) {
                    s.classList.add('selected');
                } else {
                    s.classList.remove('selected');
                }
            });
        }
        
        function selectSuggestion(name) {
            document.getElementById('searchInput').value = name;
            document.getElementById('autocompleteSuggestions').classList.remove('active');
            searchReferee();
        }
        
        function generateNACTabs() {
            const nacTabsContainer = document.getElementById('nacSubTabs');
            
            // Get all unique season-NAC combinations
            const nacEvents = {};
            
            refereeData.forEach(record => {
                const date = new Date(record.date);
                const month = date.getMonth(); // 0-11
                const year = date.getFullYear();
                
                // Determine the season (Aug-July)
                let season;
                if (month >= 7) { // Aug-Dec
                    season = `${year}-${year + 1}`;
                } else { // Jan-July
                    season = `${year - 1}-${year}`;
                }
                
                // Determine the NAC
                let nacName;
                let nacKey;
                if (date.getMonth() === 5 && date.getDate() >= 27) { // June 27+
                    nacName = 'Summer Nationals';
                    nacKey = `${season}|Summer Nationals`;
                } else if (date.getMonth() === 6 && date.getDate() <= 15) { // July 1-15
                    nacName = 'Summer Nationals';
                    nacKey = `${season}|Summer Nationals`;
                } else {
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    nacName = monthNames[month] + ' NAC';
                    
                    // Special case for February
                    if (month === 1) {
                        nacName = 'Jr Olympics';
                    }
                    
                    nacKey = `${season}|${nacName}`;
                }
                
                if (!nacEvents[nacKey]) {
                    nacEvents[nacKey] = {
                        season: season,
                        nacName: nacName,
                        displayName: `${nacName} ${season.slice(-4)}`, // e.g., "Jan NAC 2025"
                        sortOrder: month === 5 || month === 6 ? 99 : month, // Summer Nationals at end
                        key: nacKey
                    };
                }
            });
            
            // Sort NACs by season and month
            const sortedNACs = Object.values(nacEvents).sort((a, b) => {
                if (a.season !== b.season) {
                    return b.season.localeCompare(a.season); // Newest season first
                }
                return a.sortOrder - b.sortOrder;
            });
            
            // Generate tabs HTML
            let tabsHTML = '<button class="sub-tab active" onclick="showNAC(\'all\', \'all\')">All NACs</button>';
            
            let currentSeason = '';
            sortedNACs.forEach(nac => {
                if (nac.season !== currentSeason) {
                    if (currentSeason !== '') {
                        tabsHTML += '<div style="width: 100%; height: 1px; background-color: #ddd; margin: 10px 0;"></div>';
                    }
                    currentSeason = nac.season;
                    tabsHTML += `<div style="width: 100%; font-weight: bold; padding: 5px; color: #1a472a;">${currentSeason}</div>`;
                }
                tabsHTML += `<button class="sub-tab" onclick="showNAC('${nac.season}', '${nac.nacName}')">${nac.displayName}</button>`;
            });
            
            nacTabsContainer.innerHTML = tabsHTML;
        }
        
        function showNAC(season, nacName) {
            currentNACSeason = season;
            currentNAC = nacName;
            
            // Update sub-tab UI
            const subTabs = document.querySelectorAll('#nacSubTabs .sub-tab');
            subTabs.forEach(tab => {
                tab.classList.remove('active');
                if ((season === 'all' && tab.textContent === 'All NACs') || 
                    (season !== 'all' && tab.textContent.includes(nacName) && tab.textContent.includes(season.slice(-4)))) {
                    tab.classList.add('active');
                }
            });
            
            displayNACStats();
        }
        
        function displayNACStats() {
            let filteredData = refereeData;
            
            // Filter by NAC if selected
            if (currentNAC !== 'all' && currentNACSeason !== 'all') {
                filteredData = filteredData.filter(record => {
                    const date = new Date(record.date);
                    const month = date.getMonth();
                    const year = date.getFullYear();
                    
                    // Check season
                    let recordSeason;
                    if (month >= 7) { // Aug-Dec
                        recordSeason = `${year}-${year + 1}`;
                    } else { // Jan-July
                        recordSeason = `${year - 1}-${year}`;
                    }
                    
                    if (recordSeason !== currentNACSeason) return false;
                    
                    // Check NAC
                    if (currentNAC === 'Summer Nationals') {
                        return (date.getMonth() === 5 && date.getDate() >= 27) || 
                               (date.getMonth() === 6 && date.getDate() <= 15);
                    } else if (currentNAC === 'Jr Olympics') {
                        return date.getMonth() === 1;
                    } else {
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        const nacMonth = monthNames[month] + ' NAC';
                        return nacMonth === currentNAC && month !== 1; // Exclude Feb from NAC (it's Jr Olympics)
                    }
                });
            }
            
            // Apply search filter
            if (searchTerm) {
                filteredData = filteredData.filter(d => 
                    d.referee.toLowerCase().includes(searchTerm)
                );
            }
            
            // Aggregate by referee
            const refereeAggregated = {};
            
            for (const record of filteredData) {
                const referee = record.referee;
                
                if (!refereeAggregated[referee]) {
                    refereeAggregated[referee] = {
                        referee: referee,
                        totalMatches: 0,
                        headRefMatches: 0,
                        videoRefMatches: 0,
                        pools: 0,
                        finals: 0,
                        weapons: new Set(),
                        events: new Set()
                    };
                }
                
                refereeAggregated[referee].totalMatches += record.totalMatches;
                refereeAggregated[referee].headRefMatches += record.headRefMatches;
                refereeAggregated[referee].videoRefMatches += record.videoRefMatches;
                refereeAggregated[referee].pools += record.pools;
                refereeAggregated[referee].finals += record.finals;
                refereeAggregated[referee].weapons.add(record.weapon);
                refereeAggregated[referee].events.add(record.event);
            }
            
            // Convert to array and sort
            let leaderboardData = Object.values(refereeAggregated);
            
            // Apply sorting
            if (sortColumn !== null) {
                leaderboardData.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch(sortColumn) {
                        case 'referee':
                            aVal = a.referee;
                            bVal = b.referee;
                            break;
                        case 'totalMatches':
                            aVal = a.totalMatches;
                            bVal = b.totalMatches;
                            break;
                        case 'finals':
                            aVal = a.finals;
                            bVal = b.finals;
                            break;
                        case 'pools':
                            aVal = a.pools;
                            bVal = b.pools;
                            break;
                        case 'headRefMatches':
                            aVal = a.headRefMatches;
                            bVal = b.headRefMatches;
                            break;
                        case 'videoRefMatches':
                            aVal = a.videoRefMatches;
                            bVal = b.videoRefMatches;
                            break;
                        case 'headRefPercentage':
                            aVal = a.totalMatches > 0 ? (a.headRefMatches / a.totalMatches) : 0;
                            bVal = b.totalMatches > 0 ? (b.headRefMatches / b.totalMatches) : 0;
                            break;
                        case 'events':
                            aVal = a.events.size;
                            bVal = b.events.size;
                            break;
                        default:
                            aVal = a.totalMatches;
                            bVal = b.totalMatches;
                    }
                    
                    if (typeof aVal === 'string') {
                        return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else {
                        return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                    }
                });
            } else {
                leaderboardData.sort((a, b) => b.totalMatches - a.totalMatches);
            }
            
            // Display statistics
            const statsContainer = document.getElementById('statsContainer');
            let nacLabel;
            if (currentNAC === 'all') {
                nacLabel = 'All NACs';
            } else {
                const year = currentNACSeason.slice(-4);
                nacLabel = `${currentNAC} ${year}`;
            }
            
            const totalReferees = leaderboardData.length;
            const totalMatches = leaderboardData.reduce((sum, ref) => sum + ref.totalMatches, 0);
            const totalFinals = leaderboardData.reduce((sum, ref) => sum + ref.finals, 0);
            const totalPools = leaderboardData.reduce((sum, ref) => sum + ref.pools, 0);
            
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h3>${totalReferees}</h3>
                    <p>Referees at ${nacLabel}</p>
                </div>
                <div class="stat-card">
                    <h3>${totalMatches.toLocaleString()}</h3>
                    <p>Total Matches</p>
                </div>
                <div class="stat-card">
                    <h3>${totalFinals.toLocaleString()}</h3>
                    <p>Finals Officiated</p>
                </div>
                <div class="stat-card">
                    <h3>${totalPools.toLocaleString()}</h3>
                    <p>Pools Officiated</p>
                </div>
            `;
            
            // Display leaderboard
            const container = document.getElementById('leaderboardContainer');
            
            if (leaderboardData.length === 0) {
                container.innerHTML = '<p>No data found for the selected NAC.</p>';
                return;
            }
            
            let tableHTML = `
                <h2 style="margin-bottom: 20px; color: #1a472a;">${nacLabel}</h2>
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th onclick="sortTable('rank')">Rank</th>
                            <th onclick="sortTable('referee')">Referee Name</th>
                            <th onclick="sortTable('totalMatches')">Total Matches</th>
                            <th onclick="sortTable('finals')">Finals</th>
                            <th onclick="sortTable('pools')">Pools</th>
                            <th onclick="sortTable('headRefMatches')">Head Ref</th>
                            <th onclick="sortTable('videoRefMatches')">Video Ref</th>
                            <th onclick="sortTable('headRefPercentage')">Head Ref %</th>
                            <th onclick="sortTable('events')">Events</th>
                            <th>Weapons</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            leaderboardData.forEach((referee, index) => {
                const headRefPercentage = referee.totalMatches > 0 
                    ? ((referee.headRefMatches / referee.totalMatches) * 100).toFixed(1)
                    : '0.0';
                
                // Simplify weapons display
                const weapons = Array.from(referee.weapons);
                const hasEpee = weapons.some(w => w.includes('Epee'));
                const hasFoil = weapons.some(w => w.includes('Foil'));
                const hasSaber = weapons.some(w => w.includes('Saber'));
                
                const simplifiedWeapons = [];
                if (hasSaber) simplifiedWeapons.push('Saber');
                if (hasEpee) simplifiedWeapons.push('Epee');
                if (hasFoil) simplifiedWeapons.push('Foil');
                
                const weaponsDisplay = simplifiedWeapons.join(', ');
                
                tableHTML += `
                    <tr>
                        <td class="rank">${index + 1}</td>
                        <td>${referee.referee}</td>
                        <td>${referee.totalMatches}</td>
                        <td>${referee.finals}</td>
                        <td>${referee.pools}</td>
                        <td>${referee.headRefMatches}</td>
                        <td>${referee.videoRefMatches}</td>
                        <td class="percentage">${headRefPercentage}%</td>
                        <td>${referee.events.size}</td>
                        <td>${weaponsDisplay}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = tableHTML;
        }
        
        function displayFinalsLeaderboard() {
            // Hide weapon tabs for finals view
            document.getElementById('subTabs').style.display = 'none';
            
            let filteredFinalsData = finalsData;
            
            // Apply search filter if active
            if (searchTerm) {
                filteredFinalsData = filteredFinalsData.filter(d => 
                    d.referee.toLowerCase().includes(searchTerm)
                );
            }
            
            // Filter to only count Finals (Gold Medal matches)
            filteredFinalsData = filteredFinalsData.filter(d => d.round === 'Finals');
            
            // Aggregate by referee (combining head and video roles)
            const refereeAggregated = {};
            
            for (const record of filteredFinalsData) {
                const referee = record.referee;
                
                if (!refereeAggregated[referee]) {
                    refereeAggregated[referee] = {
                        referee: referee,
                        totalFinals: 0,
                        headRefCount: 0,
                        videoRefCount: 0,
                        weaponBreakdown: {
                            'Men\'s Saber': 0,
                            'Women\'s Saber': 0,
                            'Men\'s Epee': 0,
                            'Women\'s Epee': 0,
                            'Men\'s Foil': 0,
                            'Women\'s Foil': 0
                        }
                    };
                }
                
                refereeAggregated[referee].totalFinals += record.count;
                refereeAggregated[referee].weaponBreakdown[record.weapon] += record.count;
                
                if (record.role === 'Head Referee') {
                    refereeAggregated[referee].headRefCount += record.count;
                } else if (record.role === 'Video Referee') {
                    refereeAggregated[referee].videoRefCount += record.count;
                }
            }
            
            // Convert to array and sort
            let finalsLeaderboard = Object.values(refereeAggregated);
            
            // Apply sorting for finals
            if (sortColumn !== null) {
                finalsLeaderboard.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch(sortColumn) {
                        case 'referee':
                            aVal = a.referee;
                            bVal = b.referee;
                            break;
                        case 'totalFinals':
                            aVal = a.totalFinals;
                            bVal = b.totalFinals;
                            break;
                        case 'headRefCount':
                            aVal = a.headRefCount;
                            bVal = b.headRefCount;
                            break;
                        case 'videoRefCount':
                            aVal = a.videoRefCount;
                            bVal = b.videoRefCount;
                            break;
                        default:
                            // Check if it's a weapon column
                            if (sortColumn.startsWith('weapon_')) {
                                const weapon = sortColumn.replace('weapon_', '').replace(/_/g, ' ');
                                aVal = a.weaponBreakdown[weapon] || 0;
                                bVal = b.weaponBreakdown[weapon] || 0;
                            } else {
                                aVal = a.totalFinals;
                                bVal = b.totalFinals;
                            }
                    }
                    
                    if (typeof aVal === 'string') {
                        return sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else {
                        return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                    }
                });
            } else {
                finalsLeaderboard.sort((a, b) => b.totalFinals - a.totalFinals);
            }
            
            // Display stats
            const statsContainer = document.getElementById('statsContainer');
            const totalFinalsReferees = finalsLeaderboard.length;
            const totalFinalsOfficiated = finalsLeaderboard.reduce((sum, ref) => sum + ref.totalFinals, 0);
            const headRefTotal = finalsLeaderboard.reduce((sum, ref) => sum + ref.headRefCount, 0);
            const videoRefTotal = finalsLeaderboard.reduce((sum, ref) => sum + ref.videoRefCount, 0);
            
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h3>${totalFinalsReferees}</h3>
                    <p>Finals Referees</p>
                </div>
                <div class="stat-card">
                    <h3>${totalFinalsOfficiated.toLocaleString()}</h3>
                    <p>Total Finals</p>
                </div>
                <div class="stat-card">
                    <h3>${headRefTotal.toLocaleString()}</h3>
                    <p>As Head Referee</p>
                </div>
                <div class="stat-card">
                    <h3>${videoRefTotal.toLocaleString()}</h3>
                    <p>As Video Referee</p>
                </div>
            `;
            
            // Display leaderboard
            const container = document.getElementById('leaderboardContainer');
            
            if (finalsLeaderboard.length === 0) {
                container.innerHTML = '<p>No finals data found.</p>';
                return;
            }
            
            let tableHTML = `
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th onclick="sortFinalsTable('rank')">Rank</th>
                            <th onclick="sortFinalsTable('referee')">Referee Name</th>
                            <th onclick="sortFinalsTable('totalFinals')">Finals</th>
                            <th onclick="sortFinalsTable('headRefCount')">Finals Head Ref</th>
                            <th onclick="sortFinalsTable('videoRefCount')">Finals Video Ref</th>
                            <th onclick="sortFinalsTable('weapon_Men\\'s Saber')">MS</th>
                            <th onclick="sortFinalsTable('weapon_Women\\'s Saber')">WS</th>
                            <th onclick="sortFinalsTable('weapon_Men\\'s Epee')">ME</th>
                            <th onclick="sortFinalsTable('weapon_Women\\'s Epee')">WE</th>
                            <th onclick="sortFinalsTable('weapon_Men\\'s Foil')">MF</th>
                            <th onclick="sortFinalsTable('weapon_Women\\'s Foil')">WF</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            finalsLeaderboard.forEach((referee, index) => {
                tableHTML += `
                    <tr>
                        <td class="rank">${index + 1}</td>
                        <td>${referee.referee}</td>
                        <td><strong>${referee.totalFinals}</strong></td>
                        <td>${referee.headRefCount}</td>
                        <td>${referee.videoRefCount}</td>
                        <td>${referee.weaponBreakdown['Men\'s Saber'] || '-'}</td>
                        <td>${referee.weaponBreakdown['Women\'s Saber'] || '-'}</td>
                        <td>${referee.weaponBreakdown['Men\'s Epee'] || '-'}</td>
                        <td>${referee.weaponBreakdown['Women\'s Epee'] || '-'}</td>
                        <td>${referee.weaponBreakdown['Men\'s Foil'] || '-'}</td>
                        <td>${referee.weaponBreakdown['Women\'s Foil'] || '-'}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = tableHTML;
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                // Load data from GitHub
                const allData = await loadDataFromGitHub();
                refereeData = allData.filter(d => !d.isFinalsDetail);
                finalsData = allData.filter(d => d.isFinalsDetail);
                console.log(`Loaded ${refereeData.length} referee records and ${finalsData.length} finals detail records`);
                
                // Initial display
                updateDisplay();
                
                // Setup autocomplete
                setupAutocomplete();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('leaderboardContainer').innerHTML = 
                    '<div class="error">Error loading data. Please check the console for details.</div>';
            }
        });
    </script>
</body>
</html>
