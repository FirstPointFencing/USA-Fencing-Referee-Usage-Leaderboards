<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USA Fencing Referee Commission Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .data-source {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .data-source a {
            color: #ffd700;
            text-decoration: none;
            font-weight: bold;
        }

        .data-source a:hover {
            text-decoration: underline;
        }

        .file-input-container {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #667eea;
        }

        .file-input-container input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .file-input-label:hover {
            transform: scale(1.05);
        }

        .loaded-files {
            margin-top: 15px;
            color: #27ae60;
            font-weight: bold;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .nav-tab {
            padding: 10px 20px;
            background: #e0e0e0;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .nav-tab:hover {
            background: #d0d0d0;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sub-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }

        .sub-tab {
            padding: 8px 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .sub-tab:hover {
            background: #f0f0f0;
        }

        .sub-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .content-panel {
            display: none;
            animation: fadeIn 0.5s;
        }

        .content-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: rgba(255,255,255,0.1);
        }

        th.sortable::after {
            content: '‚Üï';
            position: absolute;
            right: 10px;
            opacity: 0.5;
        }

        th.sort-asc::after {
            content: '‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: '‚Üì';
            opacity: 1;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tbody tr:hover {
            background: #f5f5f5;
        }

        tbody tr:nth-child(even) {
            background: #fafafa;
        }

        .highlight {
            background: #fff3cd !important;
            font-weight: bold;
        }

        .finals-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: #ffd700;
            color: #333;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .video-ref-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 0.85em;
        }

        .percentage-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .percentage-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .percentage-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85em;
            font-weight: bold;
            color: #333;
        }

        .weapon-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin: 2px;
        }

        .weapon-foil {
            background: #e74c3c;
            color: white;
        }

        .weapon-epee {
            background: #3498db;
            color: white;
        }

        .weapon-sabre {
            background: #2ecc71;
            color: white;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            flex: 1;
            min-width: 200px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
        }

        .export-btn {
            padding: 10px 20px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .export-btn:hover {
            background: #229954;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.9em;
            }

            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§∫ USA Fencing Referee Commission Dashboard</h1>
        <p class="subtitle">Comprehensive Referee Usage Analytics & Reporting System</p>
        
        <div class="data-source">
            <p>üìä Data Source: <a href="https://firstpointfencing.github.io/USA-Fencing-Referee-Usage-Leaderboards/" target="_blank">USA Fencing Referee Usage Leaderboards Repository</a></p>
            <p>Load CSV files from the repository or upload your own data files below</p>
        </div>

        <div class="file-input-container">
            <label for="fileInput" class="file-input-label">üìÅ Upload CSV Files</label>
            <input type="file" id="fileInput" multiple accept=".csv">
            <div class="loaded-files" id="loadedFiles"></div>
        </div>

        <div id="mainContent" style="display: none;">
            <div class="nav-tabs" id="seasonTabs">
                <!-- Season tabs will be dynamically generated -->
            </div>

            <div id="contentArea">
                <!-- Dynamic content will be loaded here -->
            </div>
        </div>

        <div class="loading" id="loadingMessage">
            <div class="spinner"></div>
            <p>Please upload CSV files or load data from the repository to begin...</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        // Global data storage
        let refereeData = [];
        let processedData = {};
        let currentSeason = null;
        let currentTournament = null;
        let currentWeapon = null;
        let currentView = 'aggregate';

        // Event codes and weapons from project knowledge
        const eventCodes = {
            youth: ['Y10', 'Y12', 'Y14'],
            cadet: ['CDT', 'U17', 'U16'],
            junior: ['Jr', 'U20'],
            senior: ['Sr', 'SRTM'],
            division: ['Div1', 'Div2', 'Div3', 'D1A'],
            veteran: ['Vet', 'VetTM', 'V40', 'V50', 'V60', 'V70'],
            championship: ['CHR', 'JTM', 'CTM', 'STM']
        };

        const weaponCodes = {
            'MF': { name: 'Men\'s Foil', weapon: 'Foil', class: 'weapon-foil' },
            'WF': { name: 'Women\'s Foil', weapon: 'Foil', class: 'weapon-foil' },
            'ME': { name: 'Men\'s Epee', weapon: 'Epee', class: 'weapon-epee' },
            'WE': { name: 'Women\'s Epee', weapon: 'Epee', class: 'weapon-epee' },
            'MS': { name: 'Men\'s Sabre', weapon: 'Sabre', class: 'weapon-sabre' },
            'WS': { name: 'Women\'s Sabre', weapon: 'Sabre', class: 'weapon-sabre' }
        };

        // Tournament dates from project knowledge
        const tournamentDates = {
            '2024-25': [
                { name: 'May SJCC', start: '2025-05-15', end: '2025-05-19' },
                { name: 'April NAC', start: '2025-04-11', end: '2025-04-13' },
                { name: 'March NAC', start: '2025-03-06', end: '2025-03-11' },
                { name: 'Junior Olympics', start: '2025-02-14', end: '2025-02-17' },
                { name: 'January NAC', start: '2025-01-03', end: '2025-01-06' },
                { name: 'December SJCC', start: '2024-12-06', end: '2024-12-08' },
                { name: 'November NAC', start: '2024-11-08', end: '2024-11-11' },
                { name: 'October NAC', start: '2024-10-04', end: '2024-10-07' }
            ],
            '2023-24': [
                { name: 'Summer Nationals', start: '2024-06-30', end: '2024-07-08' },
                { name: 'April NAC', start: '2024-04-25', end: '2024-04-28' },
                { name: 'March SJCC', start: '2024-03-15', end: '2024-03-17' },
                { name: 'March NAC', start: '2024-03-01', end: '2024-03-04' },
                { name: 'Junior Olympics', start: '2024-02-16', end: '2024-02-19' },
                { name: 'January NAC', start: '2024-01-05', end: '2024-01-08' },
                { name: 'Dec SJCC + NAC', start: '2023-12-01', end: '2023-12-04' },
                { name: 'November NAC', start: '2023-11-10', end: '2023-11-13' },
                { name: 'October NAC', start: '2023-10-26', end: '2023-10-29' }
            ]
        };

        // File input handler
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                loadCSVFiles(files);
            }
        }

        function loadCSVFiles(files) {
            let loadedCount = 0;
            const fileNames = [];

            Array.from(files).forEach(file => {
                fileNames.push(file.name);
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    Papa.parse(e.target.result, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            processCSVData(results.data, file.name);
                            loadedCount++;
                            
                            if (loadedCount === files.length) {
                                document.getElementById('loadedFiles').innerHTML = 
                                    `‚úÖ Loaded ${files.length} file(s): ${fileNames.join(', ')}`;
                                processAllData();
                                displayDashboard();
                            }
                        }
                    });
                };
                
                reader.readAsText(file);
            });
        }

        function processCSVData(data, fileName) {
            // Extract season from filename (e.g., "Referee_Usage_20232024_Part1.csv")
            const seasonMatch = fileName.match(/(\d{4})(\d{4})/);
            const season = seasonMatch ? `${seasonMatch[1]}-${seasonMatch[2].slice(-2)}` : 'Unknown';

            data.forEach(row => {
                // Clean headers by trimming whitespace
                const cleanRow = {};
                Object.keys(row).forEach(key => {
                    cleanRow[key.trim()] = row[key];
                });

                const processedRow = {
                    lastName: cleanRow['Last Name'] || '',
                    firstName: cleanRow['First Name'] || '',
                    event: cleanRow['Event'] || '',
                    date: cleanRow['Date'] || '',
                    memberId: cleanRow['Member #'] || '',
                    season: season,
                    tournament: identifyTournament(cleanRow['Date'], season),
                    weapon: extractWeapon(cleanRow['Event']),
                    eventCategory: extractEventCategory(cleanRow['Event']),
                    bouts: parseBouts(cleanRow)
                };

                if (processedRow.lastName && processedRow.firstName) {
                    refereeData.push(processedRow);
                }
            });
        }

        function identifyTournament(dateStr, season) {
            if (!dateStr) return 'Unknown Tournament';
            
            // Parse date in MM/DD/YYYY or M/D/YYYY format
            const parts = dateStr.split('/');
            if (parts.length !== 3) return 'Unknown Tournament';
            
            const month = parseInt(parts[0]);
            const day = parseInt(parts[1]);
            const year = parseInt(parts[2]);
            
            const eventDate = new Date(year, month - 1, day);
            
            // Find matching tournament
            const tournaments = tournamentDates[season] || [];
            for (let tournament of tournaments) {
                const start = new Date(tournament.start);
                const end = new Date(tournament.end);
                
                if (eventDate >= start && eventDate <= end) {
                    return tournament.name;
                }
            }
            
            return `Tournament ${month}/${year}`;
        }

        function extractWeapon(eventCode) {
            if (!eventCode) return 'Unknown';
            
            const code = eventCode.toUpperCase();
            for (let suffix in weaponCodes) {
                if (code.endsWith(suffix)) {
                    return weaponCodes[suffix].weapon;
                }
            }
            return 'Unknown';
        }

        function extractEventCategory(eventCode) {
            if (!eventCode) return 'Unknown';
            
            const code = eventCode.toUpperCase();
            
            for (let category in eventCodes) {
                for (let prefix of eventCodes[category]) {
                    if (code.startsWith(prefix.toUpperCase())) {
                        return category.charAt(0).toUpperCase() + category.slice(1);
                    }
                }
            }
            return 'Open';
        }

        function parseBouts(row) {
            const bouts = {
                pools: 0,
                table512: 0,
                table256: 0,
                table128: 0,
                table64: 0,
                table32: 0,
                table16: 0,
                table8: 0,
                semiFinals: 0,
                bronzeMedal: 0,
                finals: 0,
                videoRef: 0,
                totalRef: 0,
                totalVideo: 0
            };

            // Round columns mapping
            const roundMappings = {
                'Pools': 'pools',
                'Table of 512': 'table512',
                'Table of 256': 'table256',
                'Table of 128': 'table128',
                'Table of 64': 'table64',
                'Table of 32': 'table32',
                'Table of 16': 'table16',
                'Table of 8': 'table8',
                'Semi-Finals': 'semiFinals',
                'Bronze Medal Matches': 'bronzeMedal',
                'Finals': 'finals'
            };

            // Parse each round
            Object.keys(roundMappings).forEach(columnName => {
                const value = row[columnName];
                if (value && typeof value === 'string') {
                    // Extract referee count
                    const refMatch = value.match(/Ref:\s*(\d+)/);
                    if (refMatch) {
                        const count = parseInt(refMatch[1]);
                        bouts[roundMappings[columnName]] = count;
                        bouts.totalRef += count;
                    }
                    
                    // Extract video referee count
                    const videoMatch = value.match(/Video:\s*(\d+)/);
                    if (videoMatch) {
                        const count = parseInt(videoMatch[1]);
                        bouts.videoRef += count;
                        bouts.totalVideo += count;
                    }
                }
            });

            return bouts;
        }

        function processAllData() {
            processedData = {};
            
            refereeData.forEach(entry => {
                const season = entry.season;
                const tournament = entry.tournament;
                const weapon = entry.weapon;
                const refName = `${entry.lastName}, ${entry.firstName}`;
                
                // Initialize season
                if (!processedData[season]) {
                    processedData[season] = {
                        tournaments: {},
                        seasonStats: {},
                        weapons: {}
                    };
                }
                
                // Initialize tournament
                if (!processedData[season].tournaments[tournament]) {
                    processedData[season].tournaments[tournament] = {
                        referees: {},
                        weapons: {},
                        stats: {
                            totalBouts: 0,
                            totalReferees: 0,
                            totalFinals: 0
                        }
                    };
                }
                
                // Initialize weapon for season
                if (!processedData[season].weapons[weapon]) {
                    processedData[season].weapons[weapon] = {};
                }
                
                // Initialize weapon for tournament
                if (!processedData[season].tournaments[tournament].weapons[weapon]) {
                    processedData[season].tournaments[tournament].weapons[weapon] = {};
                }
                
                // Process referee stats
                addRefereeStats(processedData[season].tournaments[tournament].referees, refName, entry);
                addRefereeStats(processedData[season].tournaments[tournament].weapons[weapon], refName, entry);
                addRefereeStats(processedData[season].seasonStats, refName, entry);
                addRefereeStats(processedData[season].weapons[weapon], refName, entry);
            });
            
            // Calculate tournament counts for season stats
            Object.keys(processedData).forEach(season => {
                const seasonData = processedData[season];
                Object.keys(seasonData.seasonStats).forEach(refName => {
                    const ref = seasonData.seasonStats[refName];
                    const tournamentsSet = new Set();
                    
                    refereeData.forEach(entry => {
                        if (entry.season === season && 
                            `${entry.lastName}, ${entry.firstName}` === refName) {
                            tournamentsSet.add(entry.tournament);
                        }
                    });
                    
                    ref.tournamentCount = tournamentsSet.size;
                });
            });
        }

        function addRefereeStats(container, refName, entry) {
            if (!container[refName]) {
                container[refName] = {
                    matches: 0,
                    videoMatches: 0,
                    finals: 0,
                    videoFinals: 0,
                    events: new Set(),
                    poolBouts: 0,
                    tableBouts: 0,
                    tournamentCount: 0
                };
            }
            
            const ref = container[refName];
            const bouts = entry.bouts;
            
            ref.matches += bouts.totalRef;
            ref.videoMatches += bouts.totalVideo;
            ref.finals += bouts.finals;
            ref.videoFinals += (bouts.finals > 0 && bouts.totalVideo > 0) ? 1 : 0;
            ref.events.add(entry.event);
            ref.poolBouts += bouts.pools;
            ref.tableBouts += (bouts.totalRef - bouts.pools);
        }

        function displayDashboard() {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // Create season tabs
            const seasonTabs = document.getElementById('seasonTabs');
            seasonTabs.innerHTML = '';
            
            const seasons = Object.keys(processedData).sort().reverse();
            
            seasons.forEach((season, index) => {
                const tab = document.createElement('button');
                tab.className = 'nav-tab' + (index === 0 ? ' active' : '');
                tab.textContent = `Season ${season}`;
                tab.onclick = () => selectSeason(season);
                seasonTabs.appendChild(tab);
            });
            
            if (seasons.length > 0) {
                selectSeason(seasons[0]);
            }
        }

        function selectSeason(season) {
            currentSeason = season;
            
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.includes(season)) {
                    tab.classList.add('active');
                }
            });
            
            // Display season content
            displaySeasonContent(season);
        }

        function displaySeasonContent(season) {
            const contentArea = document.getElementById('contentArea');
            const seasonData = processedData[season];
            
            let html = `
                <div class="sub-tabs">
                    <button class="sub-tab active" onclick="showSeasonOverview('${season}')">Season Overview</button>
            `;
            
            // Add tournament tabs
            Object.keys(seasonData.tournaments).forEach(tournament => {
                html += `<button class="sub-tab" onclick="showTournament('${season}', '${tournament}')">${tournament}</button>`;
            });
            
            html += `</div><div id="subContent"></div>`;
            
            contentArea.innerHTML = html;
            showSeasonOverview(season);
        }

        function showSeasonOverview(season) {
            updateSubTabActive('Season Overview');
            const seasonData = processedData[season];
            const subContent = document.getElementById('subContent');
            
            // Calculate overall stats
            let totalBouts = 0;
            let totalReferees = Object.keys(seasonData.seasonStats).length;
            let totalFinals = 0;
            let totalTournaments = Object.keys(seasonData.tournaments).length;
            
            Object.values(seasonData.seasonStats).forEach(ref => {
                totalBouts += ref.matches;
                totalFinals += ref.finals;
            });
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${totalReferees}</div>
                        <div class="stat-label">Total Referees</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalTournaments}</div>
                        <div class="stat-label">Tournaments</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalBouts.toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalFinals}</div>
                        <div class="stat-label">Finals Refereed</div>
                    </div>
                </div>
                
                <div class="filter-controls">
                    <input type="text" class="filter-input" placeholder="Search referee..." onkeyup="filterTable(this, 'seasonTable')">
                    <select class="filter-select" onchange="filterByWeapon(this.value, '${season}')">
                        <option value="all">All Weapons</option>
                        <option value="Foil">Foil</option>
                        <option value="Epee">Epee</option>
                        <option value="Sabre">Sabre</option>
                    </select>
                    <button class="export-btn" onclick="exportToCSV('${season}')">Export to CSV</button>
                </div>
                
                <table id="seasonTable">
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('seasonTable', 0)">Referee Name</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 1)">Matches (Ref)</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 2)">Video Ref</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 3)">Video %</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 4)">Finals</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 5)">Video Finals</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 6)">Events</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 7)">Tournaments</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 8)">Pool Bouts</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 9)">Table Bouts</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            Object.entries(seasonData.seasonStats).forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.videoFinals}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.tournamentCount}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table>`;
            
            // Add weapon-specific tables
            html += `<h3 style="margin-top: 40px;">Season Statistics by Weapon</h3>`;
            
            ['Foil', 'Epee', 'Sabre'].forEach(weapon => {
                if (seasonData.weapons[weapon] && Object.keys(seasonData.weapons[weapon]).length > 0) {
                    html += createWeaponTable(seasonData.weapons[weapon], weapon, `${season}-${weapon}`);
                }
            });
            
            subContent.innerHTML = html;
        }

        function showTournament(season, tournament) {
            updateSubTabActive(tournament);
            currentTournament = tournament;
            const tournamentData = processedData[season].tournaments[tournament];
            const subContent = document.getElementById('subContent');
            
            // Calculate tournament stats
            let totalBouts = 0;
            let totalReferees = Object.keys(tournamentData.referees).length;
            let totalFinals = 0;
            
            Object.values(tournamentData.referees).forEach(ref => {
                totalBouts += ref.matches;
                totalFinals += ref.finals;
            });
            
            let html = `
                <h2>${tournament}</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${totalReferees}</div>
                        <div class="stat-label">Referees</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalBouts.toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalFinals}</div>
                        <div class="stat-label">Finals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Object.keys(tournamentData.weapons).length}</div>
                        <div class="stat-label">Weapons</div>
                    </div>
                </div>
                
                <h3>Aggregate Statistics - All Weapons</h3>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable">Referee Name</th>
                            <th class="sortable">Matches (Ref)</th>
                            <th class="sortable">Video Ref</th>
                            <th class="sortable">Video %</th>
                            <th class="sortable">Finals</th>
                            <th class="sortable">Video Finals</th>
                            <th class="sortable">Events</th>
                            <th class="sortable">Pool Bouts</th>
                            <th class="sortable">Table Bouts</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            Object.entries(tournamentData.referees).forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.videoFinals}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table>`;
            
            // Add weapon-specific tables for tournament
            html += `<h3 style="margin-top: 40px;">Tournament Statistics by Weapon</h3>`;
            
            ['Foil', 'Epee', 'Sabre'].forEach(weapon => {
                if (tournamentData.weapons[weapon] && Object.keys(tournamentData.weapons[weapon]).length > 0) {
                    html += createWeaponTable(tournamentData.weapons[weapon], weapon, `${tournament}-${weapon}`);
                }
            });
            
            subContent.innerHTML = html;
        }

        function createWeaponTable(weaponData, weaponName, tableId) {
            const weaponClass = weaponName.toLowerCase();
            let html = `
                <div style="margin-top: 30px;">
                    <h4><span class="weapon-badge weapon-${weaponClass}">${weaponName}</span> Statistics</h4>
                    <table id="${tableId}">
                        <thead>
                            <tr>
                                <th class="sortable">Referee Name</th>
                                <th class="sortable">Matches (Ref)</th>
                                <th class="sortable">Video Ref</th>
                                <th class="sortable">Video %</th>
                                <th class="sortable">Finals</th>
                                <th class="sortable">Events</th>
                                <th class="sortable">Pool Bouts</th>
                                <th class="sortable">Table Bouts</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            Object.entries(weaponData).forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table></div>`;
            return html;
        }

        function updateSubTabActive(tabName) {
            document.querySelectorAll('.sub-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent === tabName) {
                    tab.classList.add('active');
                }
            });
        }

        function sortTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const th = table.getElementsByTagName('th')[columnIndex];
            
            // Determine sort direction
            let ascending = !th.classList.contains('sort-asc');
            
            // Remove all sort indicators
            table.querySelectorAll('th').forEach(header => {
                header.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add new sort indicator
            th.classList.add(ascending ? 'sort-asc' : 'sort-desc');
            
            // Sort rows
            rows.sort((a, b) => {
                const aValue = a.getElementsByTagName('td')[columnIndex].textContent;
                const bValue = b.getElementsByTagName('td')[columnIndex].textContent;
                
                // Try to parse as number
                const aNum = parseFloat(aValue.replace(/[^0-9.-]/g, ''));
                const bNum = parseFloat(bValue.replace(/[^0-9.-]/g, ''));
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return ascending ? aNum - bNum : bNum - aNum;
                }
                
                // Sort as string
                return ascending ? 
                    aValue.localeCompare(bValue) : 
                    bValue.localeCompare(aValue);
            });
            
            // Reorder rows
            rows.forEach(row => tbody.appendChild(row));
        }

        function filterTable(input, tableId) {
            const filter = input.value.toUpperCase();
            const table = document.getElementById(tableId);
            const rows = table.getElementsByTagName('tr');
            
            for (let i = 1; i < rows.length; i++) {
                const nameCell = rows[i].getElementsByTagName('td')[0];
                if (nameCell) {
                    const textValue = nameCell.textContent || nameCell.innerText;
                    rows[i].style.display = textValue.toUpperCase().indexOf(filter) > -1 ? '' : 'none';
                }
            }
        }

        function filterByWeapon(weapon, season) {
            if (weapon === 'all') {
                showSeasonOverview(season);
            } else {
                const seasonData = processedData[season];
                const weaponData = seasonData.weapons[weapon];
                
                if (weaponData && Object.keys(weaponData).length > 0) {
                    const subContent = document.getElementById('subContent');
                    subContent.innerHTML = createWeaponTable(weaponData, weapon, `filtered-${weapon}`);
                }
            }
        }

        function exportToCSV(season) {
            const seasonData = processedData[season];
            let csv = 'Referee Name,Matches (Ref),Video Ref,Video %,Finals,Video Finals,Events,Tournaments,Pool Bouts,Table Bouts\n';
            
            Object.entries(seasonData.seasonStats).forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                csv += `"${refName}",${stats.matches},${stats.videoMatches},${videoPercentage}%,${stats.finals},${stats.videoFinals},${stats.events.size},${stats.tournamentCount},${stats.poolBouts},${stats.tableBouts}\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `referee_usage_${season}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Load sample data for demonstration
        function loadSampleData() {
            // This would normally load from the GitHub repository
            // For now, showing the structure ready for data
            document.getElementById('loadingMessage').innerHTML = `
                <div class="spinner"></div>
                <p>Ready to load data. Please upload CSV files from the 
                <a href="https://firstpointfencing.github.io/USA-Fencing-Referee-Usage-Leaderboards/" target="_blank">repository</a>
                or use the upload button above.</p>
            `;
        }

        // Initialize
        loadSampleData();
    </script>
</body>
</html>