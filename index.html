<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USA Fencing Referee Commission Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .data-source {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .data-source a {
            color: #ffd700;
            text-decoration: none;
            font-weight: bold;
        }

        .data-source a:hover {
            text-decoration: underline;
        }

        .loading-status {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #667eea;
        }

        .loading-status.success {
            border-color: #27ae60;
            background: #d4edda;
            color: #155724;
        }

        .loading-status.error {
            border-color: #e74c3c;
            background: #f8d7da;
            color: #721c24;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .nav-tab {
            padding: 10px 20px;
            background: #e0e0e0;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .nav-tab:hover {
            background: #d0d0d0;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .sub-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }

        .sub-tab {
            padding: 8px 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .sub-tab:hover {
            background: #f0f0f0;
        }

        .sub-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .content-panel {
            display: none;
            animation: fadeIn 0.5s;
        }

        .content-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: rgba(255,255,255,0.1);
        }

        th.sortable::after {
            content: 'â†•';
            position: absolute;
            right: 10px;
            opacity: 0.5;
        }

        th.sort-asc::after {
            content: 'â†‘';
            opacity: 1;
        }

        th.sort-desc::after {
            content: 'â†“';
            opacity: 1;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tbody tr:hover {
            background: #f5f5f5;
        }

        tbody tr:nth-child(even) {
            background: #fafafa;
        }

        .highlight {
            background: #fff3cd !important;
            font-weight: bold;
        }

        .finals-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: #ffd700;
            color: #333;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .video-ref-indicator {
            display: inline-block;
            padding: 3px 8px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 0.85em;
        }

        .percentage-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .percentage-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .percentage-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.85em;
            font-weight: bold;
            color: #333;
        }

        .weapon-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin: 2px;
        }

        .weapon-foil {
            background: #e74c3c;
            color: white;
        }

        .weapon-epee {
            background: #3498db;
            color: white;
        }

        .weapon-sabre {
            background: #2ecc71;
            color: white;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            flex: 1;
            min-width: 200px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
        }

        .export-btn {
            padding: 10px 20px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .export-btn:hover {
            background: #229954;
        }

        .error-message {
            color: #e74c3c;
            text-align: center;
            padding: 20px;
            background: #ffe6e6;
            border-radius: 10px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.9em;
            }

            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¤º USA Fencing Referee Commission Dashboard</h1>
        <p class="subtitle">Comprehensive Referee Usage Analytics & Reporting System</p>
        
        <div class="data-source">
            <p>ðŸ“Š Data Source: <a href="https://github.com/FirstPointFencing/USA-Fencing-Referee-Usage-Leaderboards" target="_blank">USA Fencing Referee Usage Leaderboards Repository</a></p>
            <p>Automatically loading data from GitHub repository...</p>
        </div>

        <div class="loading-status" id="loadingStatus">
            <div class="spinner"></div>
            <p>Loading referee usage data from repository...</p>
        </div>

        <div id="mainContent" style="display: none;">
            <div class="nav-tabs" id="seasonTabs">
                <!-- Season tabs will be dynamically generated -->
            </div>

            <div id="contentArea">
                <!-- Dynamic content will be loaded here -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        // Global data storage
        let refereeData = [];
        let processedData = {};
        let currentSeason = null;
        let currentTournament = null;
        let currentWeapon = null;
        let currentView = 'aggregate';

        // CSV files to load from GitHub
        const csvFiles = [
            'Referee_Usage_20242025_Part1.csv',
            'Referee_Usage_20242025_Part2.csv',
            'Referee_Usage_20232024_Part1.csv',
            'Referee_Usage_20232024_Part2.csv',
            'Referee_Usage_20222023_Part1.csv',
            'Referee_Usage_20222023_Part2.csv',
            'Referee_Usage_20212022.csv',
            'Referee_Usage_20202021.csv',
            'Referee_Usage_20192020.csv',
            'Referee_Usage_20182019.csv',
            'Referee_Usage_20172018.csv',
            'Referee_Usage_20162017.csv',
            'Referee_Usage_20152016.csv',
            'Referee_Usage_20142015.csv'
        ];

        // Event codes and weapons from project knowledge
        const eventCodes = {
            youth: ['Y10', 'Y12', 'Y14'],
            cadet: ['CDT', 'U17', 'U16'],
            junior: ['Jr', 'U20', 'U19'],
            senior: ['Sr', 'SRTM', 'STM'],
            division: ['Div1', 'Div2', 'Div3', 'D1A', 'DV1', 'DV2', 'DV3'],
            veteran: ['Vet', 'VetTM', 'V40', 'V50', 'V60', 'V70', 'VET'],
            championship: ['CHR', 'JTM', 'CTM', 'STM']
        };

        const weaponCodes = {
            'MF': { name: 'Men\'s Foil', weapon: 'Foil', class: 'weapon-foil' },
            'WF': { name: 'Women\'s Foil', weapon: 'Foil', class: 'weapon-foil' },
            'ME': { name: 'Men\'s Epee', weapon: 'Epee', class: 'weapon-epee' },
            'WE': { name: 'Women\'s Epee', weapon: 'Epee', class: 'weapon-epee' },
            'MS': { name: 'Men\'s Sabre', weapon: 'Sabre', class: 'weapon-sabre' },
            'WS': { name: 'Women\'s Sabre', weapon: 'Sabre', class: 'weapon-sabre' }
        };

        // Tournament dates from project knowledge
        const tournamentDates = {
            '2024-25': [
                { name: 'May SJCC', start: '2025-05-15', end: '2025-05-19' },
                { name: 'April NAC', start: '2025-04-11', end: '2025-04-14' },
                { name: 'March NAC', start: '2025-03-06', end: '2025-03-11' },
                { name: 'Junior Olympics', start: '2025-02-14', end: '2025-02-17' },
                { name: 'January NAC', start: '2025-01-03', end: '2025-01-06' },
                { name: 'December SJCC', start: '2024-12-06', end: '2024-12-08' },
                { name: 'November NAC', start: '2024-11-08', end: '2024-11-11' },
                { name: 'October NAC', start: '2024-10-04', end: '2024-10-07' }
            ],
            '2023-24': [
                { name: 'Summer Nationals', start: '2024-06-30', end: '2024-07-08' },
                { name: 'April NAC', start: '2024-04-25', end: '2024-04-28' },
                { name: 'March SJCC', start: '2024-03-15', end: '2024-03-17' },
                { name: 'March NAC', start: '2024-03-01', end: '2024-03-04' },
                { name: 'Junior Olympics', start: '2024-02-16', end: '2024-02-19' },
                { name: 'January NAC', start: '2024-01-05', end: '2024-01-08' },
                { name: 'Dec SJCC + NAC', start: '2023-12-01', end: '2023-12-04' },
                { name: 'November NAC', start: '2023-11-10', end: '2023-11-13' },
                { name: 'October NAC', start: '2023-10-26', end: '2023-10-29' }
            ],
            '2022-23': [
                { name: 'Summer Nationals', start: '2023-06-30', end: '2023-07-09' },
                { name: 'June SJCC', start: '2023-06-02', end: '2023-06-04' },
                { name: 'April NAC', start: '2023-04-21', end: '2023-04-24' },
                { name: 'March NAC', start: '2023-03-03', end: '2023-03-06' },
                { name: 'Junior Olympics', start: '2023-02-17', end: '2023-02-20' },
                { name: 'January NAC', start: '2023-01-06', end: '2023-01-09' },
                { name: 'December NAC', start: '2022-12-09', end: '2022-12-12' },
                { name: 'October NAC', start: '2022-10-07', end: '2022-10-10' }
            ],
            '2021-22': [
                { name: 'Summer Nationals', start: '2022-07-02', end: '2022-07-11' },
                { name: 'April NAC', start: '2022-04-21', end: '2022-04-24' },
                { name: 'March NAC', start: '2022-03-04', end: '2022-03-07' }
            ]
        };

        // Load data on page load
        window.addEventListener('DOMContentLoaded', loadAllCSVFiles);

        async function loadAllCSVFiles() {
            const loadingStatus = document.getElementById('loadingStatus');
            let loadedCount = 0;
            let errorCount = 0;
            const baseUrl = 'https://raw.githubusercontent.com/FirstPointFencing/USA-Fencing-Referee-Usage-Leaderboards/main/';

            for (const fileName of csvFiles) {
                try {
                    loadingStatus.innerHTML = `
                        <div class="spinner"></div>
                        <p>Loading ${fileName}... (${loadedCount + 1}/${csvFiles.length})</p>
                    `;

                    const response = await fetch(baseUrl + fileName);
                    if (!response.ok) {
                        console.warn(`Failed to load ${fileName}: ${response.status}`);
                        errorCount++;
                        continue;
                    }

                    const text = await response.text();
                    
                    // Parse CSV
                    Papa.parse(text, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        delimitersToGuess: [',', '\t', '|', ';'],
                        complete: function(results) {
                            if (results.data && results.data.length > 0) {
                                processCSVData(results.data, fileName);
                                loadedCount++;
                            }
                        },
                        error: function(error) {
                            console.error(`Error parsing ${fileName}:`, error);
                            errorCount++;
                        }
                    });

                } catch (error) {
                    console.error(`Error loading ${fileName}:`, error);
                    errorCount++;
                }
            }

            // After all files are processed
            setTimeout(() => {
                if (loadedCount > 0) {
                    loadingStatus.className = 'loading-status success';
                    loadingStatus.innerHTML = `âœ… Successfully loaded ${loadedCount} data files`;
                    processAllData();
                    displayDashboard();
                } else {
                    loadingStatus.className = 'loading-status error';
                    loadingStatus.innerHTML = `âŒ Failed to load data files. Please check the repository connection.`;
                }
            }, 1000);
        }

        function processCSVData(data, fileName) {
            // Extract season from filename
            const seasonMatch = fileName.match(/(\d{4})(\d{4})/);
            const season = seasonMatch ? `${seasonMatch[1]}-${seasonMatch[2].slice(-2)}` : 'Unknown';

            data.forEach(row => {
                // Clean headers by trimming whitespace
                const cleanRow = {};
                Object.keys(row).forEach(key => {
                    if (key && row[key] !== null && row[key] !== undefined) {
                        cleanRow[key.trim()] = row[key];
                    }
                });

                // Handle different column name variations
                const lastName = cleanRow['Last Name'] || cleanRow[''] || '';
                const firstName = cleanRow['First Name'] || cleanRow['Name'] || '';
                const event = cleanRow['Event'] || '';
                const date = cleanRow['Date'] || '';
                
                const processedRow = {
                    lastName: lastName.toString().trim(),
                    firstName: firstName.toString().trim(),
                    event: event.toString().trim(),
                    date: date.toString().trim(),
                    memberId: cleanRow['Member #'] || cleanRow['Member#'] || '',
                    season: season,
                    tournament: identifyTournament(date, season),
                    weapon: extractWeapon(event),
                    eventCategory: extractEventCategory(event),
                    bouts: parseBouts(cleanRow)
                };

                // Only add if we have valid referee name
                if (processedRow.lastName || processedRow.firstName) {
                    refereeData.push(processedRow);
                }
            });
        }

        function identifyTournament(dateStr, season) {
            if (!dateStr || dateStr === '') return 'Unknown Tournament';
            
            // Handle different date formats
            let eventDate;
            
            // Try MM/DD/YYYY or M/D/YYYY format
            if (dateStr.includes('/')) {
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    const month = parseInt(parts[0]);
                    const day = parseInt(parts[1]);
                    const year = parseInt(parts[2]);
                    
                    if (!isNaN(month) && !isNaN(day) && !isNaN(year)) {
                        eventDate = new Date(year, month - 1, day);
                    }
                }
            }
            // Try YYYY-MM-DD format
            else if (dateStr.includes('-')) {
                eventDate = new Date(dateStr);
            }
            
            if (!eventDate || isNaN(eventDate.getTime())) {
                return `Tournament ${dateStr}`;
            }
            
            // Find matching tournament
            const tournaments = tournamentDates[season] || [];
            for (let tournament of tournaments) {
                const start = new Date(tournament.start);
                const end = new Date(tournament.end);
                
                if (eventDate >= start && eventDate <= end) {
                    return tournament.name;
                }
            }
            
            // Default tournament name based on month/year
            const month = eventDate.getMonth() + 1;
            const year = eventDate.getFullYear();
            return `Tournament ${month}/${year}`;
        }

        function extractWeapon(eventCode) {
            if (!eventCode) return 'Unknown';
            
            const code = eventCode.toUpperCase();
            for (let suffix in weaponCodes) {
                if (code.endsWith(suffix)) {
                    return weaponCodes[suffix].weapon;
                }
            }
            return 'Unknown';
        }

        function extractEventCategory(eventCode) {
            if (!eventCode) return 'Unknown';
            
            const code = eventCode.toUpperCase();
            
            for (let category in eventCodes) {
                for (let prefix of eventCodes[category]) {
                    if (code.startsWith(prefix.toUpperCase()) || 
                        code.includes(prefix.toUpperCase())) {
                        return category.charAt(0).toUpperCase() + category.slice(1);
                    }
                }
            }
            return 'Open';
        }

        function parseBouts(row) {
            const bouts = {
                pools: 0,
                table512: 0,
                table256: 0,
                table128: 0,
                table64: 0,
                table32: 0,
                table16: 0,
                table8: 0,
                semiFinals: 0,
                bronzeMedal: 0,
                finals: 0,
                videoRef: 0,
                totalRef: 0,
                totalVideo: 0
            };

            // Handle multiple pool columns as per instructions
            let poolTotal = 0;
            let table128Total = 0;

            // Process each column
            Object.keys(row).forEach(columnName => {
                const value = row[columnName];
                if (!value || typeof value !== 'string') return;

                const cleanColumn = columnName.trim().toLowerCase();
                
                // Extract referee count
                const refMatch = value.match(/Ref:\s*(\d+)/i);
                const refCount = refMatch ? parseInt(refMatch[1]) : 0;
                
                // Extract video referee count
                const videoMatch = value.match(/Video:\s*(\d+)/i);
                const videoCount = videoMatch ? parseInt(videoMatch[1]) : 0;

                // Map to appropriate bout type
                if (cleanColumn.includes('pool')) {
                    poolTotal += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('512')) {
                    bouts.table512 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('256')) {
                    bouts.table256 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('128')) {
                    table128Total += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('64')) {
                    bouts.table64 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('32')) {
                    bouts.table32 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('16')) {
                    bouts.table16 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('table of 8') || cleanColumn === 'table of 8') {
                    bouts.table8 += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('semi') || cleanColumn.includes('semi-final')) {
                    bouts.semiFinals += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('bronze') || cleanColumn.includes('third')) {
                    bouts.bronzeMedal += refCount;
                    bouts.videoRef += videoCount;
                }
                else if (cleanColumn.includes('final') && !cleanColumn.includes('semi')) {
                    bouts.finals += refCount;
                    if (videoCount > 0) {
                        bouts.videoRef += videoCount;
                    }
                }
            });

            // Apply combined totals
            bouts.pools = poolTotal;
            bouts.table128 = table128Total;
            
            // Calculate totals
            bouts.totalRef = bouts.pools + bouts.table512 + bouts.table256 + 
                           bouts.table128 + bouts.table64 + bouts.table32 + 
                           bouts.table16 + bouts.table8 + bouts.semiFinals + 
                           bouts.bronzeMedal + bouts.finals;
            
            bouts.totalVideo = bouts.videoRef;

            return bouts;
        }

        function processAllData() {
            processedData = {};
            
            refereeData.forEach(entry => {
                const season = entry.season;
                const tournament = entry.tournament;
                const weapon = entry.weapon;
                const refName = entry.lastName && entry.firstName ? 
                    `${entry.lastName}, ${entry.firstName}` : 
                    entry.lastName || entry.firstName || 'Unknown';
                
                // Initialize season
                if (!processedData[season]) {
                    processedData[season] = {
                        tournaments: {},
                        seasonStats: {},
                        weapons: {}
                    };
                }
                
                // Initialize tournament
                if (!processedData[season].tournaments[tournament]) {
                    processedData[season].tournaments[tournament] = {
                        referees: {},
                        weapons: {},
                        stats: {
                            totalBouts: 0,
                            totalReferees: 0,
                            totalFinals: 0
                        }
                    };
                }
                
                // Initialize weapon for season
                if (!processedData[season].weapons[weapon]) {
                    processedData[season].weapons[weapon] = {};
                }
                
                // Initialize weapon for tournament
                if (!processedData[season].tournaments[tournament].weapons[weapon]) {
                    processedData[season].tournaments[tournament].weapons[weapon] = {};
                }
                
                // Process referee stats
                addRefereeStats(processedData[season].tournaments[tournament].referees, refName, entry);
                addRefereeStats(processedData[season].tournaments[tournament].weapons[weapon], refName, entry);
                addRefereeStats(processedData[season].seasonStats, refName, entry);
                addRefereeStats(processedData[season].weapons[weapon], refName, entry);
            });
            
            // Calculate tournament counts for season stats
            Object.keys(processedData).forEach(season => {
                const seasonData = processedData[season];
                Object.keys(seasonData.seasonStats).forEach(refName => {
                    const ref = seasonData.seasonStats[refName];
                    const tournamentsSet = new Set();
                    
                    refereeData.forEach(entry => {
                        const entryRefName = entry.lastName && entry.firstName ? 
                            `${entry.lastName}, ${entry.firstName}` : 
                            entry.lastName || entry.firstName || 'Unknown';
                        
                        if (entry.season === season && entryRefName === refName) {
                            tournamentsSet.add(entry.tournament);
                        }
                    });
                    
                    ref.tournamentCount = tournamentsSet.size;
                });
            });
        }

        function addRefereeStats(container, refName, entry) {
            if (!container[refName]) {
                container[refName] = {
                    matches: 0,
                    videoMatches: 0,
                    finals: 0,
                    videoFinals: 0,
                    events: new Set(),
                    poolBouts: 0,
                    tableBouts: 0,
                    tournamentCount: 0,
                    top8Bouts: 0  // Quarterfinals and semifinals
                };
            }
            
            const ref = container[refName];
            const bouts = entry.bouts;
            
            ref.matches += bouts.totalRef;
            ref.videoMatches += bouts.totalVideo;
            ref.finals += bouts.finals;
            
            // Count video finals separately
            if (bouts.finals > 0 && bouts.totalVideo > 0) {
                // Check if video was specifically for finals
                ref.videoFinals += (bouts.videoRef > 0 && bouts.finals > 0) ? 1 : 0;
            }
            
            ref.events.add(entry.event);
            ref.poolBouts += bouts.pools;
            ref.tableBouts += (bouts.totalRef - bouts.pools);
            
            // Top 8 includes quarterfinals (table of 8) and semifinals
            ref.top8Bouts += bouts.table8 + bouts.semiFinals;
        }

        function displayDashboard() {
            document.getElementById('loadingStatus').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // Create season tabs
            const seasonTabs = document.getElementById('seasonTabs');
            seasonTabs.innerHTML = '';
            
            const seasons = Object.keys(processedData).sort().reverse();
            
            seasons.forEach((season, index) => {
                const tab = document.createElement('button');
                tab.className = 'nav-tab' + (index === 0 ? ' active' : '');
                tab.textContent = `Season ${season}`;
                tab.onclick = () => selectSeason(season);
                seasonTabs.appendChild(tab);
            });
            
            if (seasons.length > 0) {
                selectSeason(seasons[0]);
            }
        }

        function selectSeason(season) {
            currentSeason = season;
            
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.includes(season)) {
                    tab.classList.add('active');
                }
            });
            
            // Display season content
            displaySeasonContent(season);
        }

        function displaySeasonContent(season) {
            const contentArea = document.getElementById('contentArea');
            const seasonData = processedData[season];
            
            let html = `
                <div class="sub-tabs">
                    <button class="sub-tab active" onclick="showSeasonOverview('${season}')">Season Overview</button>
            `;
            
            // Add tournament tabs
            const tournaments = Object.keys(seasonData.tournaments).sort((a, b) => {
                // Sort tournaments chronologically if possible
                const dateA = getTournamentDate(a);
                const dateB = getTournamentDate(b);
                return dateB - dateA;  // Most recent first
            });
            
            tournaments.forEach(tournament => {
                html += `<button class="sub-tab" onclick="showTournament('${season}', '${tournament}')">${tournament}</button>`;
            });
            
            html += `</div><div id="subContent"></div>`;
            
            contentArea.innerHTML = html;
            showSeasonOverview(season);
        }

        function getTournamentDate(tournamentName) {
            // Helper function to get approximate date for sorting
            const monthMap = {
                'January': 1, 'February': 2, 'March': 3, 'April': 4,
                'May': 5, 'June': 6, 'July': 7, 'August': 8,
                'September': 9, 'October': 10, 'November': 11, 'December': 12,
                'Summer': 7, 'Junior Olympics': 2
            };
            
            for (let month in monthMap) {
                if (tournamentName.includes(month)) {
                    return monthMap[month];
                }
            }
            return 0;
        }

        function showSeasonOverview(season) {
            updateSubTabActive('Season Overview');
            const seasonData = processedData[season];
            const subContent = document.getElementById('subContent');
            
            // Calculate overall stats
            let totalBouts = 0;
            let totalReferees = Object.keys(seasonData.seasonStats).length;
            let totalFinals = 0;
            let totalTournaments = Object.keys(seasonData.tournaments).length;
            
            Object.values(seasonData.seasonStats).forEach(ref => {
                totalBouts += ref.matches;
                totalFinals += ref.finals;
            });
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${totalReferees}</div>
                        <div class="stat-label">Total Referees</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalTournaments}</div>
                        <div class="stat-label">Tournaments</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalBouts.toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalFinals}</div>
                        <div class="stat-label">Finals Refereed</div>
                    </div>
                </div>
                
                <div class="filter-controls">
                    <input type="text" class="filter-input" placeholder="Search referee..." onkeyup="filterTable(this, 'seasonTable')">
                    <select class="filter-select" onchange="filterByWeapon(this.value, '${season}')">
                        <option value="all">All Weapons</option>
                        <option value="Foil">Foil</option>
                        <option value="Epee">Epee</option>
                        <option value="Sabre">Sabre</option>
                    </select>
                    <button class="export-btn" onclick="exportToCSV('${season}')">Export to CSV</button>
                </div>
                
                <table id="seasonTable">
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('seasonTable', 0)">Referee Name</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 1)">Matches (Ref)</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 2)">Video Ref</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 3)">Video %</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 4)">Finals</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 5)">Video Finals</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 6)">Top 8</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 7)">Events</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 8)">Tournaments</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 9)">Pool Bouts</th>
                            <th class="sortable" onclick="sortTable('seasonTable', 10)">Table Bouts</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Sort referees by total matches (descending)
            const sortedRefs = Object.entries(seasonData.seasonStats)
                .sort((a, b) => b[1].matches - a[1].matches);
            
            sortedRefs.forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.videoFinals}</td>
                        <td>${stats.top8Bouts || 0}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.tournamentCount}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table>`;
            
            // Add weapon-specific tables
            html += `<h3 style="margin-top: 40px;">Season Statistics by Weapon</h3>`;
            
            ['Foil', 'Epee', 'Sabre'].forEach(weapon => {
                if (seasonData.weapons[weapon] && Object.keys(seasonData.weapons[weapon]).length > 0) {
                    html += createWeaponTable(seasonData.weapons[weapon], weapon, `${season}-${weapon}`);
                }
            });
            
            subContent.innerHTML = html;
        }

        function showTournament(season, tournament) {
            updateSubTabActive(tournament);
            currentTournament = tournament;
            const tournamentData = processedData[season].tournaments[tournament];
            const subContent = document.getElementById('subContent');
            
            // Calculate tournament stats
            let totalBouts = 0;
            let totalReferees = Object.keys(tournamentData.referees).length;
            let totalFinals = 0;
            
            Object.values(tournamentData.referees).forEach(ref => {
                totalBouts += ref.matches;
                totalFinals += ref.finals;
            });
            
            let html = `
                <h2>${tournament}</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${totalReferees}</div>
                        <div class="stat-label">Referees</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalBouts.toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalFinals}</div>
                        <div class="stat-label">Finals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Object.keys(tournamentData.weapons).length}</div>
                        <div class="stat-label">Weapons</div>
                    </div>
                </div>
                
                <h3>Aggregate Statistics - All Weapons</h3>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable">Referee Name</th>
                            <th class="sortable">Matches (Ref)</th>
                            <th class="sortable">Video Ref</th>
                            <th class="sortable">Video %</th>
                            <th class="sortable">Finals</th>
                            <th class="sortable">Video Finals</th>
                            <th class="sortable">Top 8</th>
                            <th class="sortable">Events</th>
                            <th class="sortable">Pool Bouts</th>
                            <th class="sortable">Table Bouts</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Sort referees by total matches
            const sortedRefs = Object.entries(tournamentData.referees)
                .sort((a, b) => b[1].matches - a[1].matches);
            
            sortedRefs.forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.videoFinals}</td>
                        <td>${stats.top8Bouts || 0}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table>`;
            
            // Add weapon-specific tables for tournament
            html += `<h3 style="margin-top: 40px;">Tournament Statistics by Weapon</h3>`;
            
            ['Foil', 'Epee', 'Sabre'].forEach(weapon => {
                if (tournamentData.weapons[weapon] && Object.keys(tournamentData.weapons[weapon]).length > 0) {
                    html += createWeaponTable(tournamentData.weapons[weapon], weapon, `${tournament}-${weapon}`);
                }
            });
            
            subContent.innerHTML = html;
        }

        function createWeaponTable(weaponData, weaponName, tableId) {
            const weaponClass = weaponName.toLowerCase();
            let html = `
                <div style="margin-top: 30px;">
                    <h4><span class="weapon-badge weapon-${weaponClass}">${weaponName}</span> Statistics</h4>
                    <table id="${tableId}">
                        <thead>
                            <tr>
                                <th class="sortable">Referee Name</th>
                                <th class="sortable">Matches (Ref)</th>
                                <th class="sortable">Video Ref</th>
                                <th class="sortable">Video %</th>
                                <th class="sortable">Finals</th>
                                <th class="sortable">Top 8</th>
                                <th class="sortable">Events</th>
                                <th class="sortable">Pool Bouts</th>
                                <th class="sortable">Table Bouts</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort by matches
            const sortedRefs = Object.entries(weaponData)
                .sort((a, b) => b[1].matches - a[1].matches);
            
            sortedRefs.forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                html += `
                    <tr>
                        <td><strong>${refName}</strong></td>
                        <td>${stats.matches}</td>
                        <td>${stats.videoMatches > 0 ? `<span class="video-ref-indicator">${stats.videoMatches}</span>` : '0'}</td>
                        <td>
                            <div class="percentage-bar">
                                <div class="percentage-fill" style="width: ${videoPercentage}%"></div>
                                <span class="percentage-text">${videoPercentage}%</span>
                            </div>
                        </td>
                        <td>${stats.finals > 0 ? `<span class="finals-indicator">${stats.finals}</span>` : '0'}</td>
                        <td>${stats.top8Bouts || 0}</td>
                        <td>${stats.events.size}</td>
                        <td>${stats.poolBouts}</td>
                        <td>${stats.tableBouts}</td>
                    </tr>
                `;
            });
            
            html += `</tbody></table></div>`;
            return html;
        }

        function updateSubTabActive(tabName) {
            document.querySelectorAll('.sub-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent === tabName) {
                    tab.classList.add('active');
                }
            });
        }

        function sortTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const th = table.getElementsByTagName('th')[columnIndex];
            
            // Determine sort direction
            let ascending = !th.classList.contains('sort-asc');
            
            // Remove all sort indicators
            table.querySelectorAll('th').forEach(header => {
                header.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add new sort indicator
            th.classList.add(ascending ? 'sort-asc' : 'sort-desc');
            
            // Sort rows
            rows.sort((a, b) => {
                const aValue = a.getElementsByTagName('td')[columnIndex].textContent;
                const bValue = b.getElementsByTagName('td')[columnIndex].textContent;
                
                // Try to parse as number
                const aNum = parseFloat(aValue.replace(/[^0-9.-]/g, ''));
                const bNum = parseFloat(bValue.replace(/[^0-9.-]/g, ''));
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return ascending ? aNum - bNum : bNum - aNum;
                }
                
                // Sort as string
                return ascending ? 
                    aValue.localeCompare(bValue) : 
                    bValue.localeCompare(aValue);
            });
            
            // Reorder rows
            rows.forEach(row => tbody.appendChild(row));
        }

        function filterTable(input, tableId) {
            const filter = input.value.toUpperCase();
            const table = document.getElementById(tableId);
            if (!table) return;
            
            const rows = table.getElementsByTagName('tr');
            
            for (let i = 1; i < rows.length; i++) {
                const nameCell = rows[i].getElementsByTagName('td')[0];
                if (nameCell) {
                    const textValue = nameCell.textContent || nameCell.innerText;
                    rows[i].style.display = textValue.toUpperCase().indexOf(filter) > -1 ? '' : 'none';
                }
            }
        }

        function filterByWeapon(weapon, season) {
            if (weapon === 'all') {
                showSeasonOverview(season);
            } else {
                const seasonData = processedData[season];
                const weaponData = seasonData.weapons[weapon];
                
                if (weaponData && Object.keys(weaponData).length > 0) {
                    const subContent = document.getElementById('subContent');
                    subContent.innerHTML = `
                        <h2>Season ${season} - ${weapon} Only</h2>
                        ${createWeaponTable(weaponData, weapon, `filtered-${weapon}`)}
                    `;
                }
            }
        }

        function exportToCSV(season) {
            const seasonData = processedData[season];
            let csv = 'Referee Name,Matches (Ref),Video Ref,Video %,Finals,Video Finals,Top 8,Events,Tournaments,Pool Bouts,Table Bouts\n';
            
            Object.entries(seasonData.seasonStats).forEach(([refName, stats]) => {
                const videoPercentage = stats.matches > 0 ? 
                    ((stats.videoMatches / stats.matches) * 100).toFixed(1) : 0;
                
                csv += `"${refName}",${stats.matches},${stats.videoMatches},${videoPercentage}%,${stats.finals},${stats.videoFinals},${stats.top8Bouts || 0},${stats.events.size},${stats.tournamentCount},${stats.poolBouts},${stats.tableBouts}\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `referee_usage_${season}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>