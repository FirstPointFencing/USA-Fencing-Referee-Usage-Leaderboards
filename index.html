<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USA Fencing Referee Usage Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(26, 31, 58, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            text-align: center;
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            padding-bottom: 10px;
        }

        .tab {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .tab:hover::before {
            left: 100%;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
            background: rgba(255, 255, 255, 0.08);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: #94a3b8;
            margin-top: 5px;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        }

        th {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(240, 147, 251, 0.2) 100%);
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            color: #ffffff;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: all 0.3s ease;
        }

        th:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(240, 147, 251, 0.3) 100%);
        }

        th.sortable::after {
            content: ' ⇅';
            opacity: 0.5;
            font-size: 0.8em;
        }

        th.sorted-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        th.sorted-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        td {
            padding: 12px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
        }

        tr:hover td {
            background: rgba(102, 126, 234, 0.05);
        }

        tr:last-child td {
            border-bottom: none;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #94a3b8;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(3, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .weapon-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .weapon-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .weapon-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .weapon-tab.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: transparent;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-group label {
            color: #94a3b8;
            font-size: 0.9em;
        }

        .filter-group select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚔️ USA Fencing Referee Usage Dashboard</h1>
        <p class="subtitle">Comprehensive Analysis of National Event Referee Assignments</p>
        
        <div class="tabs" id="mainTabs">
            <div class="tab active" data-tab="overall">All Time</div>
            <div class="tab" data-tab="2024/2025">2024/2025</div>
            <div class="tab" data-tab="2023/2024">2023/2024</div>
            <div class="tab" data-tab="2022/2023">2022/2023</div>
            <div class="tab" data-tab="2021/2022">2021/2022</div>
            <div class="tab" data-tab="2020/2021">2020/2021</div>
            <div class="tab" data-tab="2019/2020">2019/2020</div>
            <div class="tab" data-tab="2018/2019">2018/2019</div>
            <div class="tab" data-tab="2017/2018">2017/2018</div>
            <div class="tab" data-tab="2016/2017">2016/2017</div>
            <div class="tab" data-tab="2015/2016">2015/2016</div>
            <div class="tab" data-tab="2014/2015">2014/2015</div>
            <div class="tab" data-tab="tournaments">Tournament Usage</div>
        </div>
        
        <div id="tabContent">
            <div class="tab-content active" id="overall">
                <div class="loading">Loading referee data...</div>
            </div>
            <div class="tab-content" id="2024/2025"></div>
            <div class="tab-content" id="2023/2024"></div>
            <div class="tab-content" id="2022/2023"></div>
            <div class="tab-content" id="2021/2022"></div>
            <div class="tab-content" id="2020/2021"></div>
            <div class="tab-content" id="2019/2020"></div>
            <div class="tab-content" id="2018/2019"></div>
            <div class="tab-content" id="2017/2018"></div>
            <div class="tab-content" id="2016/2017"></div>
            <div class="tab-content" id="2015/2016"></div>
            <div class="tab-content" id="2014/2015"></div>
            <div class="tab-content" id="tournaments"></div>
        </div>
    </div>

    <script>
        // Global data storage
        let allData = [];
        let aggregatedStats = [];
        
        // Utility functions
        function parseRefCount(value) {
            if (!value || value === null || value === '') return { ref: 0, video: 0 };
            
            const str = String(value).trim();
            const refMatch = str.match(/Ref:\s*(\d+)/i);
            const videoMatch = str.match(/Video:\s*(\d+)/i);
            
            return {
                ref: refMatch ? parseInt(refMatch[1]) : 0,
                video: videoMatch ? parseInt(videoMatch[1]) : 0
            };
        }

        function getWeapon(eventCode) {
            if (!eventCode) return 'Unknown';
            const code = eventCode.toUpperCase();
            
            if (code.includes('MS')) return 'Men\'s Saber';
            if (code.includes('WS')) return 'Women\'s Saber';
            if (code.includes('ME')) return 'Men\'s Epee';
            if (code.includes('WE')) return 'Women\'s Epee';
            if (code.includes('MF')) return 'Men\'s Foil';
            if (code.includes('WF')) return 'Women\'s Foil';
            
            return 'Unknown';
        }

        function getSeason(dateStr) {
            if (!dateStr) return 'Unknown';
            const parts = dateStr.split('/');
            if (parts.length !== 3) return 'Unknown';
            
            const month = parseInt(parts[0]);
            const year = parseInt(parts[2]);
            
            if (month >= 8) {
                return `${year}/${year + 1}`;
            } else {
                return `${year - 1}/${year}`;
            }
        }

        function identifyTournament(dateStr) {
            if (!dateStr) return 'Unknown';
            
            const parts = dateStr.split('/');
            if (parts.length !== 3) return 'Unknown';
            
            const month = parseInt(parts[0]);
            const day = parseInt(parts[1]);
            const year = parseInt(parts[2]);
            
            const tournaments = {
                10: 'October NAC',
                11: 'November NAC',
                12: 'December NAC/SJCC',
                1: 'January NAC',
                2: 'Jr Olympics',
                3: 'March NAC/SJCC',
                4: 'April NAC',
                5: 'May SJCC',
                6: 'June NAC/SJCC'
            };
            
            if ((month === 6 && day >= 27) || (month === 7 && day <= 13)) {
                return 'Summer Nationals';
            }
            
            return tournaments[month] || 'Unknown';
        }

        // Process CSV files
        async function processAllFiles() {
            const githubRepo = 'https://raw.githubusercontent.com/FirstPointFencing/USA-Fencing-Referee-Usage-Leaderboards/main/';
            const files = [
                { name: 'Referee_Usage_20142015.csv', season: '2014/2015' },
                { name: 'Referee_Usage_20152016.csv', season: '2015/2016' },
                { name: 'Referee_Usage_20162017.csv', season: '2016/2017' },
                { name: 'Referee_Usage_20172018.csv', season: '2017/2018' },
                { name: 'Referee_Usage_20182019.csv', season: '2018/2019' },
                { name: 'Referee_Usage_20192020.csv', season: '2019/2020' },
                { name: 'Referee_Usage_20202021.csv', season: '2020/2021' },
                { name: 'Referee_Usage_20212022.csv', season: '2021/2022' },
                { name: 'Referee_Usage_20222023_Part1.csv', season: '2022/2023' },
                { name: 'Referee_Usage_20222023_Part2.csv', season: '2022/2023' },
                { name: 'Referee_Usage_20232024_Part1.csv', season: '2023/2024' },
                { name: 'Referee_Usage_20232024_Part2.csv', season: '2023/2024' },
                { name: 'Referee_Usage_20242025_Part1.csv', season: '2024/2025' },
                { name: 'Referee_Usage_20242025_Part2.csv', season: '2024/2025' }
            ];
            
            const processedData = [];
            
            for (const file of files) {
                try {
                    console.log(`Fetching ${file.name} from GitHub...`);
                    const response = await fetch(githubRepo + file.name);
                    
                    if (!response.ok) {
                        console.warn(`File ${file.name} not found on GitHub (${response.status})`);
                        continue;
                    }
                    
                    const content = await response.text();
                    
                    const parsed = Papa.parse(content, {
                        header: true,
                        dynamicTyping: false,
                        skipEmptyLines: true,
                        delimitersToGuess: [',', '\t', '|', ';']
                    });
                    
                    console.log(`Processing ${file.name}: ${parsed.data.length} rows`);
                    
                    parsed.data.forEach(row => {
                        const lastName = (row['Last Name'] || row[''] || '').trim();
                        const firstName = (row['First Name'] || '').trim();
                        
                        if (!lastName && !firstName) return;
                        
                        const refName = `${lastName}, ${firstName}`.replace(/,\s*,/, ',').trim();
                        const event = (row['Event'] || '').trim();
                        const date = (row['Date'] || '').trim();
                        const weapon = getWeapon(event);
                        const season = file.season;
                        const tournament = identifyTournament(date);
                        
                        // Process pools
                        let poolCount = 0;
                        for (const key in row) {
                            if (key.includes('Pools')) {
                                const counts = parseRefCount(row[key]);
                                poolCount += counts.ref + counts.video;
                            }
                        }
                        
                        // Process rounds
                        const rounds = {};
                        let totalRef = 0;
                        let totalVideo = 0;
                        
                        const roundNames = [
                            'Table of 512', 'Table of 256', 'Table of 128', 'Table of 64',
                            'Table of 32', 'Table of 16', 'Table of 8', 'Semi-Finals',
                            'Bronze Medal Matches', 'Finals'
                        ];
                        
                        roundNames.forEach(round => {
                            let roundRef = 0;
                            let roundVideo = 0;
                            
                            for (const key in row) {
                                if (key.includes(round)) {
                                    const counts = parseRefCount(row[key]);
                                    roundRef += counts.ref;
                                    roundVideo += counts.video;
                                }
                            }
                            
                            rounds[round] = { ref: roundRef, video: roundVideo };
                            totalRef += roundRef;
                            totalVideo += roundVideo;
                        });
                        
                        processedData.push({
                            name: refName,
                            firstName,
                            lastName,
                            event,
                            date,
                            weapon,
                            season,
                            tournament,
                            pools: poolCount,
                            rounds,
                            totalRef,
                            totalVideo,
                            totalBouts: totalRef + totalVideo
                        });
                    });
                } catch (e) {
                    console.error(`Error processing ${file.name}:`, e);
                }
            }
            
            return processedData;
        }

        // Aggregate statistics
        function aggregateRefereeStats(data) {
            const grouped = _.groupBy(data, 'name');
            
            return Object.entries(grouped).map(([name, records]) => {
                const stats = {
                    name,
                    totalBouts: 0,
                    totalPools: 0,
                    totalFinals: 0,
                    totalVideoRef: 0,
                    totalRef: 0,
                    totalTop8: 0,
                    eventsOfficiated: new Set(),
                    tournamentsAttended: new Set(),
                    seasons: new Set(),
                    weapons: new Set(),
                    byWeapon: {},
                    bySeason: {},
                    byTournament: {}
                };
                
                records.forEach(record => {
                    stats.totalBouts += record.totalBouts;
                    stats.totalPools += record.pools;
                    stats.totalRef += record.totalRef;
                    stats.totalVideoRef += record.totalVideo;
                    
                    stats.totalFinals += (record.rounds['Finals'].ref + record.rounds['Finals'].video);
                    
                    stats.totalTop8 += (
                        record.rounds['Table of 8'].ref + record.rounds['Table of 8'].video +
                        record.rounds['Semi-Finals'].ref + record.rounds['Semi-Finals'].video +
                        record.rounds['Finals'].ref + record.rounds['Finals'].video
                    );
                    
                    if (record.event) stats.eventsOfficiated.add(record.event);
                    if (record.tournament !== 'Unknown') {
                        stats.tournamentsAttended.add(`${record.season}-${record.tournament}`);
                    }
                    if (record.season !== 'Unknown') stats.seasons.add(record.season);
                    if (record.weapon !== 'Unknown') stats.weapons.add(record.weapon);
                    
                    // By weapon
                    if (!stats.byWeapon[record.weapon]) {
                        stats.byWeapon[record.weapon] = {
                            totalBouts: 0,
                            totalRef: 0,
                            totalVideo: 0,
                            totalFinals: 0,
                            totalTop8: 0,
                            totalPools: 0,
                            events: new Set()
                        };
                    }
                    stats.byWeapon[record.weapon].totalBouts += record.totalBouts;
                    stats.byWeapon[record.weapon].totalRef += record.totalRef;
                    stats.byWeapon[record.weapon].totalVideo += record.totalVideo;
                    stats.byWeapon[record.weapon].totalFinals += (record.rounds['Finals'].ref + record.rounds['Finals'].video);
                    stats.byWeapon[record.weapon].totalTop8 += stats.totalTop8;
                    stats.byWeapon[record.weapon].totalPools += record.pools;
                    if (record.event) stats.byWeapon[record.weapon].events.add(record.event);
                    
                    // By season
                    if (!stats.bySeason[record.season]) {
                        stats.bySeason[record.season] = {
                            totalBouts: 0,
                            totalRef: 0,
                            totalVideo: 0,
                            totalFinals: 0,
                            totalPools: 0,
                            totalTop8: 0,
                            eventsOfficiated: new Set(),
                            tournaments: new Set()
                        };
                    }
                    stats.bySeason[record.season].totalBouts += record.totalBouts;
                    stats.bySeason[record.season].totalRef += record.totalRef;
                    stats.bySeason[record.season].totalVideo += record.totalVideo;
                    stats.bySeason[record.season].totalFinals += (record.rounds['Finals'].ref + record.rounds['Finals'].video);
                    stats.bySeason[record.season].totalPools += record.pools;
                    stats.bySeason[record.season].totalTop8 += (
                        record.rounds['Table of 8'].ref + record.rounds['Table of 8'].video +
                        record.rounds['Semi-Finals'].ref + record.rounds['Semi-Finals'].video +
                        record.rounds['Finals'].ref + record.rounds['Finals'].video
                    );
                    if (record.event) stats.bySeason[record.season].eventsOfficiated.add(record.event);
                    if (record.tournament !== 'Unknown') stats.bySeason[record.season].tournaments.add(record.tournament);
                    
                    // By tournament
                    const tournamentKey = `${record.season}-${record.tournament}`;
                    if (!stats.byTournament[tournamentKey]) {
                        stats.byTournament[tournamentKey] = {
                            tournament: record.tournament,
                            season: record.season,
                            totalBouts: 0,
                            totalFinals: 0,
                            events: new Set(),
                            byWeapon: {}
                        };
                    }
                    stats.byTournament[tournamentKey].totalBouts += record.totalBouts;
                    stats.byTournament[tournamentKey].totalFinals += (record.rounds['Finals'].ref + record.rounds['Finals'].video);
                    if (record.event) stats.byTournament[tournamentKey].events.add(record.event);
                    
                    if (!stats.byTournament[tournamentKey].byWeapon[record.weapon]) {
                        stats.byTournament[tournamentKey].byWeapon[record.weapon] = {
                            bouts: 0,
                            finals: 0,
                            events: new Set()
                        };
                    }
                    stats.byTournament[tournamentKey].byWeapon[record.weapon].bouts += record.totalBouts;
                    stats.byTournament[tournamentKey].byWeapon[record.weapon].finals += (record.rounds['Finals'].ref + record.rounds['Finals'].video);
                    if (record.event) stats.byTournament[tournamentKey].byWeapon[record.weapon].events.add(record.event);
                });
                
                // Convert sets to counts
                stats.eventsCount = stats.eventsOfficiated.size;
                stats.tournamentsCount = stats.tournamentsAttended.size;
                stats.seasonsCount = stats.seasons.size;
                
                stats.videoRefPercentage = stats.totalBouts > 0 ? 
                    ((stats.totalVideoRef / stats.totalBouts) * 100).toFixed(1) : '0.0';
                
                // Convert event sets in sub-objects
                Object.keys(stats.bySeason).forEach(season => {
                    stats.bySeason[season].eventsCount = stats.bySeason[season].eventsOfficiated.size;
                    stats.bySeason[season].tournamentsCount = stats.bySeason[season].tournaments.size;
                });
                
                Object.keys(stats.byWeapon).forEach(weapon => {
                    stats.byWeapon[weapon].eventsCount = stats.byWeapon[weapon].events.size;
                });
                
                Object.keys(stats.byTournament).forEach(tournament => {
                    stats.byTournament[tournament].eventsCount = stats.byTournament[tournament].events.size;
                    Object.keys(stats.byTournament[tournament].byWeapon).forEach(weapon => {
                        stats.byTournament[tournament].byWeapon[weapon].eventsCount = 
                            stats.byTournament[tournament].byWeapon[weapon].events.size;
                    });
                });
                
                return stats;
            });
        }

        // Table sorting
        function makeSortable(table) {
            const headers = table.querySelectorAll('th.sortable');
            headers.forEach((header, index) => {
                header.addEventListener('click', () => {
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const isAsc = header.classList.contains('sorted-asc');
                    
                    // Remove sorted classes from all headers
                    headers.forEach(h => {
                        h.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    
                    // Sort rows
                    rows.sort((a, b) => {
                        const aVal = a.cells[index].textContent;
                        const bVal = b.cells[index].textContent;
                        
                        // Try to parse as number
                        const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
                        const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));
                        
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return isAsc ? bNum - aNum : aNum - bNum;
                        } else {
                            return isAsc ? 
                                bVal.localeCompare(aVal) : 
                                aVal.localeCompare(bVal);
                        }
                    });
                    
                    // Re-append sorted rows
                    rows.forEach(row => tbody.appendChild(row));
                    
                    // Update header class
                    header.classList.add(isAsc ? 'sorted-desc' : 'sorted-asc');
                });
            });
        }

        // Render functions
        function renderOverallStats(stats) {
            const top20 = _.orderBy(stats, ['totalBouts'], ['desc']).slice(0, 20);
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${stats.length}</div>
                        <div class="stat-label">Total Referees</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.reduce((sum, r) => sum + r.totalBouts, 0).toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.reduce((sum, r) => sum + r.totalFinals, 0)}</div>
                        <div class="stat-label">Total Finals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.reduce((sum, r) => sum + r.totalPools, 0).toLocaleString()}</div>
                        <div class="stat-label">Total Pools</div>
                    </div>
                </div>
                
                <div class="weapon-tabs">
                    <div class="weapon-tab active" data-weapon="all">All Weapons</div>
                    <div class="weapon-tab" data-weapon="Men's Saber">Men's Saber</div>
                    <div class="weapon-tab" data-weapon="Women's Saber">Women's Saber</div>
                    <div class="weapon-tab" data-weapon="Men's Epee">Men's Epee</div>
                    <div class="weapon-tab" data-weapon="Women's Epee">Women's Epee</div>
                    <div class="weapon-tab" data-weapon="Men's Foil">Men's Foil</div>
                    <div class="weapon-tab" data-weapon="Women's Foil">Women's Foil</div>
                </div>
                
                <div id="overallTableContainer">
                    ${renderRefereeTable(top20, 'all')}
                </div>
            `;
            
            return html;
        }

        function renderRefereeTable(refs, weapon = 'all') {
            let filteredRefs = refs;
            
            if (weapon !== 'all') {
                filteredRefs = refs.filter(r => r.byWeapon[weapon] && r.byWeapon[weapon].totalBouts > 0)
                    .map(r => ({
                        ...r,
                        displayBouts: r.byWeapon[weapon].totalBouts,
                        displayRef: r.byWeapon[weapon].totalRef,
                        displayVideo: r.byWeapon[weapon].totalVideo,
                        displayFinals: r.byWeapon[weapon].totalFinals,
                        displayTop8: r.byWeapon[weapon].totalTop8,
                        displayPools: r.byWeapon[weapon].totalPools || 0,
                        displayEvents: r.byWeapon[weapon].eventsCount || 0,
                        displayVideoPercentage: r.byWeapon[weapon].totalBouts > 0 ? 
                            ((r.byWeapon[weapon].totalVideo / r.byWeapon[weapon].totalBouts) * 100).toFixed(1) : '0.0'
                    }))
                    .sort((a, b) => b.displayBouts - a.displayBouts)
                    .slice(0, 20);
            } else {
                filteredRefs = refs.map(r => ({
                    ...r,
                    displayBouts: r.totalBouts,
                    displayRef: r.totalRef,
                    displayVideo: r.totalVideoRef,
                    displayFinals: r.totalFinals,
                    displayTop8: r.totalTop8,
                    displayPools: r.totalPools,
                    displayEvents: r.eventsCount,
                    displayVideoPercentage: r.videoRefPercentage
                }));
            }
            
            return `
                <table>
                    <thead>
                        <tr>
                            <th class="sortable">Rank</th>
                            <th class="sortable">Name</th>
                            <th class="sortable sorted-desc">Total Bouts</th>
                            <th class="sortable">Pools</th>
                            <th class="sortable">Finals</th>
                            <th class="sortable">Ref</th>
                            <th class="sortable">Video Ref</th>
                            <th class="sortable">Video %</th>
                            <th class="sortable">Top 8</th>
                            <th class="sortable">Events</th>
                            <th class="sortable">Tournaments</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${filteredRefs.map((ref, idx) => `
                            <tr>
                                <td>${idx + 1}</td>
                                <td>${ref.name}</td>
                                <td>${ref.displayBouts}</td>
                                <td>${ref.displayPools}</td>
                                <td>${ref.displayFinals}</td>
                                <td>${ref.displayRef}</td>
                                <td>${ref.displayVideo}</td>
                                <td>${ref.displayVideoPercentage}%</td>
                                <td>${ref.displayTop8}</td>
                                <td>${ref.displayEvents}</td>
                                <td>${ref.tournamentsCount || 0}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function renderSeasonStats(stats, season) {
            const seasonRefs = stats.filter(r => r.bySeason[season] && r.bySeason[season].totalBouts > 0)
                .map(r => ({
                    ...r,
                    seasonData: r.bySeason[season]
                }))
                .sort((a, b) => b.seasonData.totalBouts - a.seasonData.totalBouts);
            
            const top20 = seasonRefs.slice(0, 20);
            
            return `
                <h2>Season ${season}</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${seasonRefs.length}</div>
                        <div class="stat-label">Referees Used</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${seasonRefs.reduce((sum, r) => sum + r.seasonData.totalBouts, 0).toLocaleString()}</div>
                        <div class="stat-label">Total Bouts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${seasonRefs.reduce((sum, r) => sum + r.seasonData.totalFinals, 0)}</div>
                        <div class="stat-label">Total Finals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${seasonRefs.reduce((sum, r) => sum + r.seasonData.totalPools, 0).toLocaleString()}</div>
                        <div class="stat-label">Total Pools</div>
                    </div>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th class="sortable">Rank</th>
                            <th class="sortable">Name</th>
                            <th class="sortable sorted-desc">Total Bouts</th>
                            <th class="sortable">Pools</th>
                            <th class="sortable">Finals</th>
                            <th class="sortable">Ref</th>
                            <th class="sortable">Video Ref</th>
                            <th class="sortable">Video %</th>
                            <th class="sortable">Top 8</th>
                            <th class="sortable">Events</th>
                            <th class="sortable">Tournaments</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${top20.map((ref, idx) => {
                            const videoPercentage = ref.seasonData.totalBouts > 0 ? 
                                ((ref.seasonData.totalVideo / ref.seasonData.totalBouts) * 100).toFixed(1) : '0.0';
                            return `
                            <tr>
                                <td>${idx + 1}</td>
                                <td>${ref.name}</td>
                                <td>${ref.seasonData.totalBouts}</td>
                                <td>${ref.seasonData.totalPools}</td>
                                <td>${ref.seasonData.totalFinals}</td>
                                <td>${ref.seasonData.totalRef}</td>
                                <td>${ref.seasonData.totalVideo}</td>
                                <td>${videoPercentage}%</td>
                                <td>${ref.seasonData.totalTop8}</td>
                                <td>${ref.seasonData.eventsCount}</td>
                                <td>${ref.seasonData.tournamentsCount || 0}</td>
                            </tr>
                        `}).join('')}
                    </tbody>
                </table>
            `;
        }

        function renderTournamentStats(stats) {
            // Group tournaments by type
            const tournamentGroups = {};
            const tournamentTypes = [
                'October NAC', 'November NAC', 'December NAC/SJCC', 'January NAC',
                'Jr Olympics', 'March NAC/SJCC', 'April NAC', 'May SJCC',
                'June NAC/SJCC', 'Summer Nationals'
            ];
            
            tournamentTypes.forEach(type => {
                tournamentGroups[type] = [];
            });
            
            // Collect tournament data for each referee
            stats.forEach(ref => {
                Object.entries(ref.byTournament).forEach(([key, data]) => {
                    if (data.tournament !== 'Unknown' && tournamentGroups[data.tournament]) {
                        tournamentGroups[data.tournament].push({
                            name: ref.name,
                            season: data.season,
                            totalBouts: data.totalBouts,
                            totalFinals: data.totalFinals,
                            eventsCount: data.eventsCount,
                            byWeapon: data.byWeapon
                        });
                    }
                });
            });
            
            let html = `
                <h2>Tournament Usage Analysis</h2>
                <div class="weapon-tabs">
                    <div class="weapon-tab active" data-tournament-weapon="all">All Weapons</div>
                    <div class="weapon-tab" data-tournament-weapon="Men's Saber">Men's Saber</div>
                    <div class="weapon-tab" data-tournament-weapon="Women's Saber">Women's Saber</div>
                    <div class="weapon-tab" data-tournament-weapon="Men's Epee">Men's Epee</div>
                    <div class="weapon-tab" data-tournament-weapon="Women's Epee">Women's Epee</div>
                    <div class="weapon-tab" data-tournament-weapon="Men's Foil">Men's Foil</div>
                    <div class="weapon-tab" data-tournament-weapon="Women's Foil">Women's Foil</div>
                </div>
                <div id="tournamentTableContainer">
            `;
            
            tournamentTypes.forEach(tournament => {
                if (tournamentGroups[tournament].length > 0) {
                    const aggregated = {};
                    
                    tournamentGroups[tournament].forEach(ref => {
                        if (!aggregated[ref.name]) {
                            aggregated[ref.name] = {
                                name: ref.name,
                                totalBouts: 0,
                                totalFinals: 0,
                                events: new Set(),
                                seasons: new Set(),
                                byWeapon: {}
                            };
                        }
                        
                        aggregated[ref.name].totalBouts += ref.totalBouts;
                        aggregated[ref.name].totalFinals += ref.totalFinals;
                        aggregated[ref.name].seasons.add(ref.season);
                        
                        Object.entries(ref.byWeapon).forEach(([weapon, weaponData]) => {
                            if (!aggregated[ref.name].byWeapon[weapon]) {
                                aggregated[ref.name].byWeapon[weapon] = {
                                    bouts: 0,
                                    finals: 0,
                                    events: 0
                                };
                            }
                            aggregated[ref.name].byWeapon[weapon].bouts += weaponData.bouts;
                            aggregated[ref.name].byWeapon[weapon].finals += weaponData.finals;
                            aggregated[ref.name].byWeapon[weapon].events += weaponData.eventsCount;
                        });
                    });
                    
                    const sortedRefs = Object.values(aggregated)
                        .sort((a, b) => b.totalBouts - a.totalBouts)
                        .slice(0, 20);
                    
                    html += `
                        <div class="tournament-section" data-tournament="${tournament}">
                            <h3>${tournament}</h3>
                            <table class="tournament-table-all">
                                <thead>
                                    <tr>
                                        <th class="sortable">Rank</th>
                                        <th class="sortable">Name</th>
                                        <th class="sortable sorted-desc">Total Bouts</th>
                                        <th class="sortable">Finals</th>
                                        <th class="sortable">Events</th>
                                        <th class="sortable">Seasons</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedRefs.map((ref, idx) => `
                                        <tr>
                                            <td>${idx + 1}</td>
                                            <td>${ref.name}</td>
                                            <td>${ref.totalBouts}</td>
                                            <td>${ref.totalFinals}</td>
                                            <td>${ref.events.size}</td>
                                            <td>${ref.seasons.size}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                            ${Object.keys(sortedRefs[0]?.byWeapon || {}).map(weapon => {
                                const weaponRefs = sortedRefs
                                    .filter(r => r.byWeapon[weapon] && r.byWeapon[weapon].bouts > 0)
                                    .sort((a, b) => b.byWeapon[weapon].bouts - a.byWeapon[weapon].bouts)
                                    .slice(0, 20);
                                
                                return `
                                    <table class="tournament-table-${weapon.replace(/['\s]/g, '-')}" style="display: none;">
                                        <thead>
                                            <tr>
                                                <th class="sortable">Rank</th>
                                                <th class="sortable">Name</th>
                                                <th class="sortable sorted-desc">Bouts</th>
                                                <th class="sortable">Finals</th>
                                                <th class="sortable">Events</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${weaponRefs.map((ref, idx) => `
                                                <tr>
                                                    <td>${idx + 1}</td>
                                                    <td>${ref.name}</td>
                                                    <td>${ref.byWeapon[weapon].bouts}</td>
                                                    <td>${ref.byWeapon[weapon].finals}</td>
                                                    <td>${ref.byWeapon[weapon].events}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                `;
                            }).join('')}
                        </div>
                    `;
                }
            });
            
            html += '</div>';
            
            return html;
        }

        // Initialize dashboard
        async function initDashboard() {
            try {
                // Process all files
                allData = await processAllFiles();
                aggregatedStats = aggregateRefereeStats(allData);
                
                // Render overall stats
                document.getElementById('overall').innerHTML = renderOverallStats(aggregatedStats);
                
                // Render season stats
                const seasons = [
                    '2024/2025', '2023/2024', '2022/2023', '2021/2022',
                    '2020/2021', '2019/2020', '2018/2019', '2017/2018',
                    '2016/2017', '2015/2016', '2014/2015'
                ];
                
                seasons.forEach(season => {
                    const element = document.getElementById(season);
                    if (element) {
                        element.innerHTML = renderSeasonStats(aggregatedStats, season);
                    }
                });
                
                // Render tournament stats
                document.getElementById('tournaments').innerHTML = renderTournamentStats(aggregatedStats);
                
                // Setup event listeners
                setupEventListeners();
                
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                document.getElementById('overall').innerHTML = `
                    <div class="error">
                        Error loading data: ${error.message}<br>
                        Please ensure all CSV files are available in the current directory.
                    </div>
                `;
            }
        }

        function setupEventListeners() {
            // Main tab switching
            document.querySelectorAll('#mainTabs .tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Update active tab
                    document.querySelectorAll('#mainTabs .tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Update content
                    const tabName = tab.dataset.tab;
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    const targetContent = document.getElementById(tabName);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });
            
            // Weapon filtering for overall stats
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('weapon-tab')) {
                    const weapon = e.target.dataset.weapon;
                    const container = e.target.closest('.tab-content');
                    
                    // Update active weapon tab
                    container.querySelectorAll('.weapon-tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update table
                    if (container.id === 'overall') {
                        const tableContainer = container.querySelector('#overallTableContainer');
                        if (weapon === 'all') {
                            const top20 = _.orderBy(aggregatedStats, ['totalBouts'], ['desc']).slice(0, 20);
                            tableContainer.innerHTML = renderRefereeTable(top20, 'all');
                        } else {
                            tableContainer.innerHTML = renderRefereeTable(aggregatedStats, weapon);
                        }
                        makeSortable(tableContainer.querySelector('table'));
                    }
                }
                
                // Tournament weapon filtering
                if (e.target.dataset.tournamentWeapon) {
                    const weapon = e.target.dataset.tournamentWeapon;
                    const container = e.target.closest('.tab-content');
                    
                    // Update active tab
                    container.querySelectorAll('.weapon-tab').forEach(t => t.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Show/hide appropriate tables
                    container.querySelectorAll('.tournament-section').forEach(section => {
                        section.querySelectorAll('table').forEach(table => {
                            table.style.display = 'none';
                        });
                        
                        if (weapon === 'all') {
                            const allTable = section.querySelector('.tournament-table-all');
                            if (allTable) allTable.style.display = 'table';
                        } else {
                            const weaponTable = section.querySelector(`.tournament-table-${weapon.replace(/['\s]/g, '-')}`);
                            if (weaponTable) weaponTable.style.display = 'table';
                        }
                    });
                }
            });
            
            // Make all tables sortable
            document.querySelectorAll('table').forEach(table => {
                makeSortable(table);
            });
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>
                    
                    